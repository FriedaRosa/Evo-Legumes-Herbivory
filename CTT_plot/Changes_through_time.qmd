---
title: "Changes_through_time_Armature"
format: pdf
editor: visual
---

# Reconstrucing changes between armature and no armature through time

#### Reading libraries & Preparing data

```{r}
rm(list=ls())
library(geiger)
library(phytools)
library(ape)
library(dplyr)
library(evobiR)
library(RColorBrewer)
```

```{r}
#| echo: false
# Read in the data and tree ============================

traitData <- read.csv("input/Matrix_all_traits.csv", stringsAsFactors = FALSE, header = TRUE)
tree <- read.tree("input/Mimo_metachronogram_mmc.tre")
tree <- as.phylo(tree)
new_tip_names<-read.csv("input/replace_tip_labels.csv")

# Preparing data =================

# Subset data by trait 
armature <- traitData %>% select(Taxon, Armatures) %>% filter(!is.na(Taxon) & !is.na(Armatures)) %>% distinct(.) # 2 species were duplicated (Acacia baileyana and Chidlowiana sanguinea)

```

#### Subsetting (optional)

Let's first reduce the data and run it as a trial: (skip this code chunk
if you want to run the full data)

```{r}
### Let's first reduce the data and run it as a trial:
# test_dd <- armature[1:20,]
# armature <- test_dd
```

#### Matching tree and data

```{r}
#| echo: false
# Matching tree and data =====================

# Correct tip names in the tree with new labels
tree2 <- tree
tree2$tip.label <- new_tip_names[[2]][match(tree$tip.label, new_tip_names[[1]])]

row.names(armature) <- armature$Taxon
sp_drop <- setdiff(tree2$tip.label, armature$Taxon)

# Drop these species from the tree, because we need matching data between tree and traits
tree3 <- drop.tip(tree2, sp_drop)
tree4 <- ladderize(tree3)

matches <- match(armature$Taxon, tree4$tip.label, nomatch = 0)
armature2 <- subset(armature, matches != 0)

setdiff(tree4$tip.label, armature2$Taxon) # 0
setdiff(armature2$Taxon, tree4$tip.label) # 0

tree <- tree4
```

```{r, fig.height=30, fig.width=10}
plotTree(tree,type="phylogram",ftype="off",lwd=1, fsize = 0.2)
nodelabels(cex=0.6) # root is node number 1739
```

##### Prepare data for Mk models for Armature

```{r}
# Make data for Mk models for Armature

armature2[armature2=="0"] <- "no_armature"
armature2[armature2=="1"] <- "armature"

trait <- unique(armature2)
trait <- ReorderData(tree, trait, taxa.names = "row names")

trait$Armatures <- as.factor(trait$Armatures)
trait$Taxon <- NULL

str(trait)
```

Clean environment to free memory:

```{r}
rm(tree2, tree3, tree4, traitData, new_tip_names, armature, matches, sp_drop)
```

#### Mk models

```{r}
# they estimate the rates of transitioning between ancestral states given a hypothesis (either equal rates(ER), or different rates(ARD))

# computing time = 4.67s
system.time(
  equal <- fitDiscrete(tree, trait, model = "ER"), gcFirst = T
  )

# computing time = 17.55s
system.time(
  ard <- fitDiscrete(tree, trait, model = "ARD")
  )

# Calculate AIC weights
aic.discrete <- setNames(c(equal$opt$aic, ard$opt$aic), c("equal", "different"))
weights <- aicw(aic.discrete)
weights # ARD model performs better for armature/no armature
```

#### Estimate ancestral states via Simmap reconstruction

```{r}
# we need a slightly different format for Simmap:
trait2 <- as.factor(trait$Armatures)
names(trait2) <- rownames(trait)

# For 100 simulation (nsim=100) --> computing time = 167.91s
system.time(
  mtrees <- make.simmap(tree, trait2, model = "ARD", nsim = 100)
)

# 2.5s
system.time(
  pd_mtrees <- describe.simmap(mtrees, plot = FALSE)
)
```

```{r,  fig.show="hold", out.width="25%", fig.height=8, fig.width=8}
# some visualizations of the simmap object and transitions
save.image("output/post_simmap_ws.RData")


densityMap_obj <- densityMap(mtrees, plot=F)
par(mar = c(5.1, 5.1, 4.1, 2.1)); plot(densityMap_obj, ftype="off")

par(mar = c(5.1, 5.1, 4.1, 2.1)); plot(density(mtrees))
par(mar = c(5.1, 5.1, 4.1, 2.1)); plot(density(mtrees),transition="armature->no_armature")
par(mar = c(5.1, 5.1, 4.1, 2.1)); plot(density(mtrees),transition="no_armature->armature")
```

We'd be interested in tracking the number of changes per unit of edge
length rather than the total number of changes because in all
reconstructed phylogeny of extant taxa there is more edge length towards
the tips of the tree than towards the root. We do this using the
following argument: type = "rate"

#### For comparison between absolute and relative number of transitions:

```{r, fig.show="hold", out.width="50%"}
par(mar = c(5.1, 5.1, 4.1, 2.1))  

# simulate null model given the estimated transition matrix Q
Q <- mtrees[[1]]$Q
#nulo<-sim.multiCtt(tree,Q,nsim=10)


# plotted transitions together with null hypothesis of rate change 
# a) total number
#plot(nulo,type="number")
plot(obj, type = "number")
title('Absolute number of trait changes')

# b) relative number 
#plot(nulo,type="rate")
plot(obj, type = "rate")
title('Relative number of trait changes')
```

#### Calculate the relative number of changes corrected by number of lineages:

Quote from Liam Revell on blog.phytools.org:

Under a constant process we expect the number of changes to increase
towards the present due to the greater edge length of that part of the
tree. To control for this we could also compute the total edge length of
each segment. This is a bit tricky, but we can do it as follows:

# Load ctt workspace

```{r}
load(file = "output/ctt_workspace.RData")
```

```{r}
system.time(ctt <- ctt(mtrees))
save.image("output/post_ctt_workspace.RData")
```

```{r}

ctt$segments
ctt$nchanges
ctt$edge.length
ctt$tree

mtrees[[1]]$mapped.edge
mtrees[[1]]$edge


states <- getStates(ctt$tree)
```

```{r}
library(RColorBrewer)
colors<-setNames(brewer.pal(3,"Set1"),letters[1:3])
plotTree(tree,ftype="off",lwd=1)
par(fg="transparent")
tiplabels(pie=to.matrix(trait2,unique(trait2)),piecol=colors[1:2],cex=0.2)
par(fg="black")

# get x and y coordinates for transitions (gives a list with 100 elements, each of which are the coordinates for a single Simmap simulation)
changes<-sapply(mtrees,markChanges,
                colors=sapply(colors,make.transparent,alpha=0.3))

head(changes,n=2)
```

#### Calculate the average number of transitions (the code chunk is similar to the ctt() function from phytools.)

```{r}
# get tree age:
h<-max(nodeHeights(tree))   # total hight above the root of the tree (total tree length is 25.42) = equivalent to Time
b<-20                       # number of bins
segs<-cbind(seq(0,h-h/b,h/b),
            seq(1/b*h,h,h/b))
segs                        # time in bins

# now we calculate the MEAN number of changes per time time segment (nchanges)

nchanges<-rep(0,b)
for(i in 1:length(changes)){
  for(j in 1:nrow(changes[[i]])){
    ind<-which((changes[[i]][j,1]>segs[,1])+
                 (changes[[i]][j,1]<=segs[,2])==2)
    nchanges[ind]<-nchanges[ind]+1/length(changes)
  }
}

par(mar = c(5.1, 5.1, 4.1, 2.1))    # increase margins
plot(h-as.vector(t(segs)),rbind(nchanges,nchanges),type="l",lwd=2,          # h-as.vector(t(segs)) just turns around the time (from xy to 0)
     xlim=c(max(segs),min(segs)),                                           # this restricts the time axis to the time of the clade (between 0 and the max node height)
     lend=0,xlab="time since the present",ylab="mean number of changes")

# Now we overlay the plot with the phylogenetic tree in the background (this is not necessary and just for fun)
plotTree(tree,add=TRUE,ftype="off",lwd=1,color=make.transparent("blue",0.1),
         mar=par()$mar,direction="leftwards",xlim=c(max(segs),min(segs)))
```

#### Lineages through time plot:

```{r}
system.time(
LTT<-ltt(tree,plot=FALSE))
LTT_c <- LTT # make a copy in case this goes wrong
str(LTT) 
head(LTT$ltt)
head(LTT$times)

#LTT$ltt Vectors contains the number of lineages (ltt) (we need this so that we can account for the number of lineages) (I think they are named by node number?)
# LTT$times has a vector of branching times. I think they are named by node number?

plot(LTT)
# LTT$ltt

head(LTT$ltt[2:(length(LTT$ltt)-1)])
head(LTT$times[2:(length(LTT$ltt)-1)])
head(LTT$times[3:length(LTT$ltt)])


# now lets extract the number of lineages 
LTT2<-cbind(LTT$ltt[2:(length(LTT$ltt)-1)], # cumulative number of lineages at each node
           LTT$times[2:(length(LTT$ltt)-1)], # this gives the times of splitting for nodes (root = 0, first splitting after 0.1910224 Ma, etc..)
           LTT$times[3:length(LTT$ltt)]) # same as before but without the root node

LTT <- LTT2
ii<-1
edge.length<-rep(0,b)
for(i in 1:nrow(segs)){
  done.seg<-FALSE
  while(LTT[ii,2]<=segs[i,2]&&done.seg==FALSE){
    print(i)
    edge.length[i]<-edge.length[i]+
      LTT[ii,1]*(min(segs[i,2],LTT[ii,3])-
                   max(segs[i,1],LTT[ii,2]))
    if(LTT[ii,3]>=segs[i,2]) done.seg<-TRUE
    if(LTT[ii,3]<=segs[i,2]) ii<-if(ii<nrow(LTT)) ii+1 else ii
  }
}

h<-max(nodeHeights(tree))
b<-20
segs<-cbind(seq(0,h-h/b,h/b),
    seq(1/b*h,h,h/b))
nchanges<-rep(0,b)
for(i in 1:length(changes)){
    for(j in 1:nrow(changes[[i]])){
        ind<-which((changes[[i]][j,1]>segs[,1])+
            (changes[[i]][j,1]<=segs[,2])==2)
        nchanges[ind]<-nchanges[ind]+1/length(changes)
    }
}
LTT<-ltt(tree,plot=FALSE)
LTT<-cbind(LTT$ltt[2:(length(LTT$ltt)-1)],
    LTT$times[2:(length(LTT$ltt)-1)],
    LTT$times[3:length(LTT$ltt)])
ii<-1
edge.length<-rep(0,b)
for(i in 1:nrow(segs)){
    done.seg<-FALSE
    while(LTT[ii,2]<=segs[i,2]&&done.seg==FALSE){
        edge.length[i]<-edge.length[i]+
            LTT[ii,1]*(min(segs[i,2],LTT[ii,3])-
            max(segs[i,1],LTT[ii,2]))
        if(LTT[ii,3]>=segs[i,2]) done.seg<-TRUE
        if(LTT[ii,3]<=segs[i,2]) ii<-if(ii<nrow(LTT)) ii+1 else ii
    }
}
```

```{r}
### edge.length now gives us a way to account for more species towards the present}

plot(h-as.vector(t(segs)),
    rbind(nchanges/edge.length,nchanges/edge.length), #this is the important line here !! 
    type="l",lwd=2,
    xlim=c(max(segs),min(segs)),
    lend=0,xlab="time since the present",
    ylab="mean number of changes / total edge length")

#lines(times,lineages[,1],type="s",lwd=3,col=palette()[4])
#lines(times,lineages[,2],type="s",col=palette()[2],lwd=3)



```

#### Plot lineages through time plot colored by trait state

**From: Liam Revell's [Phytools
Blog](http://blog.phytools.org/2022/07/creating-lineage-through-time-plot.html):**

Now the *question* was about graphing lineages through time, by state,
for a single stochastic mapped tree, so let's start with that.

Here what I'm going to do is take one of my mapped trees, and convert it
to a regular `"phylo"` object but with unbranching nodes (using
`phytools::map.to.singleton`).

Next, I'm going to use the *ape* function `branching.times` to compute
the height above the root of all the internal nodes in our tree. In our
phylogeny with unbranching nodes, these heights all correspond to
"events": either a bifurcation or a character state change.

Finally, I'll proceed up the tree from root to tips, and at each event
I'll *count* the number of edges in each state. This'll be fun.

```{r}
## pull tip states

x<-getStates(mtrees[[1]],"tips")
x<-as.factor(x)
head(x)


foo<-function(tree,x){
    #tt<-map.to.singleton(tree)
    H<-nodeHeights(tree)
    h<-max(H)-branching.times(tree)
    ss<-setNames(as.factor(names(tree$edge.length)),
        tree$edge[,2])
    lineages<-matrix(0,length(h),length(levels(x)),
        dimnames=list(names(h),levels(x)))
    for(i in 1:length(h)){
        ii<-intersect(which(h[i]>H[,1]),which(h[i]<=H[,2]))
        lineages[i,]<-summary(ss[ii])
    }
    ii<-order(h)
    times<-h[ii]
    lineages<-lineages[ii,]
    list(times=times,ltt=lineages)
}


ltts<-lapply(mtrees,foo,x=x)


plot(NA,xlim=range(sapply(ltts,function(x) range(x$times))),
    ylim=c(1,max(sapply(ltts,function(x) max(x$ltt)))),
    xlab="time",ylab="lineages",bty="n",las=1,log="y")
for(i in 1:length(ltts)){
    lines(ltts[[i]]$times,ltts[[i]]$ltt[,1],type="s",lwd=3,
        col=make.transparent(palette()[4],0.1))
    lines(ltts[[i]]$times,ltts[[i]]$ltt[,2],type="s",
        col=make.transparent(palette()[2],0.1),lwd=3)
}
legend("topleft",c("non-rock-dwelling","rock-dwelling"),
    pch=15,col=palette()[c(4,2)],pt.cex=1.2,cex=0.8,
    bty="n")
```

```{r}
## compute all node heights for each node in a tree 
# [,1] = height above the root , [2,] = ??

H <- nodeHeights(mtrees[[1]])

## pull out heights of all events (substract times of branching from total age)
h <- max(H)-branching.times(mtrees[[1]])

## get the states at each event
ss <- setNames(as.factor(names(mtrees[[1]]$edge.length)),
             mtrees[[1]]$edge[,2]) 
#edge[,2] = the index of the node below the edge (edge[,1] = index of the node above the edge) --> both together indicate between which nodes the edge lies

## create a (empty) matrix to count lineages
lineages<-matrix(0,length(h),length(levels(trait$Armatures)),
                 dimnames=list(names(h),levels(trait$Armatures)))
## count lineages
for(i in 1:length(h)){
  ii<-intersect(which(h[i]>H[,1]),which(h[i]<=H[,2]))
  lineages[i,]<-summary(ss[ii])
}
## sort by event
ii<-order(h)
times<-h[ii]
lineages<-lineages[ii,]
head(lineages)

```

```{r}
## create plot area
par(mar = c(5.1, 5.1, 4.1, 2.1))    # increase margins
plot(NA,xlim=range(times),ylim=c(0,max(lineages)),
     xlab="time",ylab="lineages",bty="n",las=1)

## add lineages through time for each type
lines(times,lineages[,1],type="s",lwd=3,col=palette()[4]) #armature
lines(times,lineages[,2],type="s",col=palette()[2],lwd=3) #no armature

obj<-markChanges(mtrees[[1]],plot=FALSE)


# plot lines for all changes that occurred to the plot along the x-axis
for(i in 1:nrow(obj)) lines(rep(obj[i,"x"],2),c(0,obj[i,"y"]),
                            lty="dotted",col=make.transparent("grey",0.8))



# ## superimpose tree
# cols<-setNames(make.transparent(palette()[c(4,2)],0.5),
#                levels(trait$Armature))
# plot(mtrees[[1]],cols,ftype="off",add=TRUE,lwd=1, mar=c(5.1,4.1,4.1,2.1))
# 


legend("top",c("no armature","armature"),
       pch=22,pt.bg=palette()[c(4,2)],pt.cex=1.2,cex=0.8,
       bty="n")
```

#### Adapt plot so that it shows only changes through time colored by trait

```{r}
###### Script from Pollination study: https://github.com/rubysaltbush/pollination-macroevolution/


# this function comes from https://github.com/rubysaltbush/pollination-macroevolution/blob/main/scripts/functions/transition_times.R

transition_times <- function(simmap){
  # below adapted from Liam Revells' phytools blog 
  # http://blog.phytools.org/2015/08/getting-timing-of-trait-changes-from.html
  # extracts raw transition times from a simmap (collapses multiple transitions
  # down into single transition events)
  # get tips and their states
  x <- phytools::getStates(simmap,"tips")
  # get unique states
  states <- sort(unique(x))
  # get length of states
  m <- length(states)
  # below makes a little matrix describing transitions
  ct <- sapply(states, 
               function(x,y) sapply(y, function(y,x) paste(x,"->", y, sep=""), 
                                    x = x), y = states)
  rm(x, states)
  # then a matrix to invalidate self->self transitions
  ii <- matrix(TRUE, m, m)
  diag(ii) <- rep(FALSE, m)
  # then a list to store results in
  changes <- vector(mode="list", length = m*(m - 1))
  rm(m)
  # named by types of transitions
  names(changes) <- as.vector(ct[ii])
  rm(ct, ii)
  # then singling out maps where transitions happen (where there is more than 1 state)
  nc <- sapply(simmap$maps, length) - 1
  ind <- which(nc > 0)
  nc <- nc[ind]
  
  # getting the node heights (measure of time/branch lengths) across the tree
  H <- phytools::nodeHeights(simmap)
  maps <- simmap$maps[ind]
  # then looping through and calculating the node heights of each transition
  for(i in 1:length(maps)){
    for(j in 1:nc[i]){
      sc <- paste(names(maps[[i]])[j:(j + 1)], collapse = "->")
      h <- H[ind[i], 1] + cumsum(maps[[i]])[j]
      changes[[sc]] <- c(changes[[sc]], as.numeric(h))
    }
  }
  rm(nc, ind, h, H, i, j, sc, maps)
  # removing any nulls from list of changes and sorting small to large
  changes <- changes[!sapply(changes, is.null)]
  changes <- lapply(changes, sort, decreasing = FALSE)
  
  # now convert this changes list into nice data frame output
  output <- data.frame()
  for(i in 1:length(changes)){
    df <- dplyr::bind_cols(changes[i])
    df <- df %>%
      mutate(transition = colnames(df)) %>%
      rename(nodeheight = 1)
    output <- rbind(output, df)
  }
  
  # node heights are the height above the root, so time but inverse along the tree
  # to get time from node heights need to subtract from max height of tree
  output$time <- max(nodeHeights(simmap)) - output$nodeheight
  
  # get rid of nodeheight column
  output <- output[-1]
  
  # and return the output! to graph etc.
  output
}
```

The code chunk below was modified from
[simmap.R](https://github.com/rubysaltbush/pollination-macroevolution/blob/main/scripts/analysis/simmap.R):

```{r}
# apply function across list of multiple simulations

# i is the number of the simmap simulation 
# the following code produces a dataframe of all transitions and their timings across all 100 simulations from the Simmap.


armature_transitions <- data.frame()
for(i in 1:length(mtrees)){
  temp <- cbind(i, transition_times(mtrees[[i]]))
  armature_transitions <- rbind(armature_transitions, temp)
}
rm(temp, i)

table(armature_transitions$transition)

# build new data frame with cumulative number of transitions


armature_trans_cumul <- data.frame()
for(n in 1:100){                                           # 1:1000 because they used 10000 Simmap simulations. Change this number if you use less than 1000. !!
  trans <- armature_transitions %>%
    dplyr::filter(i == i) %>%                               # here we filter by simulation for each round
    dplyr::group_by(transition) %>%                         # now we group by the direction of the transition (armature->no armature or no armature -> armature)
    dplyr::mutate(trans_no = row_number(i))                 # assigns a rank to each set of estimated transitions per simulation.
  
  armature_trans_cumul <- rbind(armature_trans_cumul, trans)
}
rm(n, trans)


##### copied from somewhere else in the code from the same script....:

# first need to know average number of transitions across all simulations, rounded
trans_avg_length <- armature_trans_cumul %>%
  dplyr::group_by(transition, i) %>%
  dplyr::mutate(no_trans = max(trans_no)) %>%
  dplyr::ungroup() %>%
  dplyr::filter(trans_no == no_trans) %>%
  dplyr::group_by(transition) %>%
  dplyr::mutate(avg_length = round(mean(no_trans), digits = 0)) %>%
  dplyr::select(transition, avg_length) %>%
  dplyr::ungroup() %>%
  dplyr::distinct()

# now knowing this, can rearrange data and average times across rows
avg_trans_times <- armature_trans_cumul %>%
  dplyr::group_by(transition, trans_no) %>%
  dplyr::mutate(avg_time = mean(time)) %>%
  dplyr::mutate(SE_time = sqrt(var(time) / length(time))) %>%
  dplyr::select(transition, trans_no, avg_time, SE_time) %>%
  dplyr::distinct()

# reduce avg_trans_times to trans_avg_length
avg_trans_times_a2na <- avg_trans_times %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
avg_trans_times_na2a <- avg_trans_times %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])

avg_trans_times <- rbind(avg_trans_times_a2na, avg_trans_times_na2a)
rm(avg_trans_times_a2na, avg_trans_times_na2a)

head(avg_trans_times)
```

```{r}
# export these results to csv in case I need them
readr::write_csv(avg_trans_times, "output/mean_transition_times_armature_MCC.csv")
```

```{r}
#### Plotting ======================================

# install.packages("prettyGraphs") #to set transparancy of colors with "alpha"
library(prettyGraphs)

myColours = c("steelblue", "#FFBB00")
myColoursAlpha <- add.alpha(myColours, alpha=0.4)
my_cols <- setNames(myColoursAlpha, c("armature->no_armature", "no_armature->armature"))

#pdf("Fig4Pollination/armature_transition_times_mean_hist.pdf", height = 2.8, width = 6)
min <- min(avg_trans_times$avg_time)
max <- max(avg_trans_times$avg_time)
ax <- pretty(min:41, n = 20)

arm_to_no_arm <- avg_trans_times %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::mutate(arm_to_no_arm = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(arm_to_no_arm)

no_arm_to_arm <- avg_trans_times %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::mutate(no_arm_to_arm = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(no_arm_to_arm)

a2na <- hist(arm_to_no_arm$arm_to_no_arm, breaks = ax, plot = FALSE)
na2a <- hist(no_arm_to_arm$no_arm_to_arm, breaks = ax, plot = FALSE)

plot (a2na, col = myColours[1], xlab = "Time of transitions (mya)",  
      main = "", ylab = "number of transitions", 
      ylim = c(0, max(a2na$counts)+2), xlim = c(50,0)) # alter if x values change!
plot (na2a, col = my_cols[2], add = TRUE)


# data for density graph
arm_to_no_arm <- armature_transitions %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::mutate(arm_to_no_arm = time) %>%
  dplyr::select(arm_to_no_arm, simulation = i)
no_arm_to_arm <- armature_transitions %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::mutate(no_arm_to_arm = time) %>%
  dplyr::select(no_arm_to_arm, simulation = i)

# calculate density curve
density_a2na <- density(arm_to_no_arm$arm_to_no_arm)
density_na2a <- density(no_arm_to_arm$no_arm_to_arm)

# plot the density
plot(density_a2na, lwd = 2, col = myColours[1], 
     xlim = c(50,0), xlab = "Time of transitions (mya)", bty = "l",
     cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
lines(density_na2a, lwd = 2, col = myColours[2], xlim = c(50,0))

# add data-points with noise in the X-axis
rug(jitter(no_arm_to_arm$no_arm_to_arm), col = my_cols[1])
rug(jitter(arm_to_no_arm$arm_to_no_arm), col = my_cols[2])

#dev.off()
##################


```

```{r}
#pdf("Fig4Pollination/RatesPlot.pdf", height = 10, width = 8)
par(mar = c(5.1, 5.1, 4.1, 2.1))    # increase margins

arm_to_no_arm <- armature_trans_cumul %>%
  dplyr::filter(transition == "armature->no_armature")

# first set up basic plot parameters
plot(arm_to_no_arm$trans_no ~ arm_to_no_arm$time,
     type = "p", bty = "l", xlim = c(50,0), ylim = c(0,60),
     col = my_cols[1], pch = 15,
     xlab = "Time of transitions (mya)", 
     ylab = "Cumulative number of transitions",
     cex.lab = 1.8, cex.axis = 1.8)

# then loop through all data and add all points and lines to plot for 1000 simulations
for(n in 1:1000){
  test <- armature_transitions %>%
    dplyr::filter(i == n) %>%
    dplyr::group_by(transition) %>%
    dplyr::mutate(trans_no = row_number(i))
  
  no_arm_to_arm <- test %>%
    dplyr::filter(transition == "no_armature->armature")
  arm_to_no_arm <- test %>%
    dplyr::filter(transition == "armature->no_armature")
  
  points(arm_to_no_arm$trans_no ~ arm_to_no_arm$time, 
         col = my_cols[1], pch = 15)
  lines(arm_to_no_arm$trans_no ~ arm_to_no_arm$time, 
        col = my_cols[1])
  points(no_arm_to_arm$trans_no ~ no_arm_to_arm$time, 
         col = my_cols[2], pch = 17)
  lines(no_arm_to_arm$trans_no ~ no_arm_to_arm$time, 
        col =my_cols[2])
}

# then add average points and line in blue
# first prep data
no_arm_to_arm <- avg_trans_times %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
arm_to_no_arm <- avg_trans_times %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])

# then add to plot
points(arm_to_no_arm$trans_no ~ arm_to_no_arm$avg_time,
       col = "blue", pch = 15)
lines(arm_to_no_arm$trans_no ~ arm_to_no_arm$avg_time, 
      col = "blue")
points(no_arm_to_arm$trans_no ~ no_arm_to_arm$avg_time,
       col = "darkblue", pch = 17)
lines(no_arm_to_arm$trans_no ~ no_arm_to_arm$avg_time, 
      col = "darkblue")

# add legend
legend("topleft",
       legend = c("armature->no_armature", "no_armature->armature"),
       col = c(my_cols[1],my_cols[2]),
       pch = c(15, 17), pt.lwd = 0.001, bty = "n", cex = 1.8)
#dev.off()

```

New try:

```{r}

### SOURCE: http://blog.phytools.org/2022/07/creating-lineage-through-time-plot.html

# Saturday, July 30, 2022
# Creating a lineage through time plot showing the number of lineages in each state from stochastic mapping
# A phytools user recently contacted me with the following interesting question:

# “I was curious if there was any way to generate something somewhat similar to a 'lineage through time' plot, but for the branches of a stochastically mapped character (e.g. showing accumulation of new branches in a given state)? Or, alternatively, if there was a way to view the proportion of branches in a given character state through time? I’ve tried playing around with timeslice'ing simmaps and am a bit unsure how best to do this.”

# Actually, I'm kind of surprised I've never shown how to do this before. (Or perhaps I have, and just forgotten.)

# Also surprisingly, it's not all that difficult. I can think of a couple of ways to do this, and I'm going to demo the easiest.

# For this example, I'll use a phylogeny & dataset for rock- and non-rock-dwelling tropidurid lizards that features in an upcoming paper by Ken Toyama, Luke Mahler, & I.

# The tree actually has a discrete character encoded, so we're going to pull that out and then run our stochastic mapping. (Normally we'd start with a phylogeny & discrete character, and then do stochastic mapping from there.)






## load phytools
library(phytools)
## read file
#url<-"https://raw.githubusercontent.com/liamrevell/evolvcv.lite.figures/main/tropidurid-tree.tre"
#legumes.tree<-read.simmap(file=url,version=1.5)

legumes.tree <- mtrees[[1]]

## pull tip states
armature<-getStates(legumes.tree,"tips")
armature<-as.factor(armature)
head(armature)

## convert tree to simple "phylo" object
legumes.tree<-as.phylo(legumes.tree)

legumes.maps<-make.simmap(legumes.tree,armature,
    model="ARD",nsim=100)

# Start preparations for plot:




# Now the question was about graphing lineages through time, by state, for a single stochastic mapped tree, so let's start with that.

# Here what I'm going to do is take one of my mapped trees, and convert it to a regular "phylo" object but with unbranching nodes (using phytools::map.to.singleton).

# Next, I'm going to use the ape function branching.times to compute the height above the root of all the internal nodes in our tree. In our phylogeny with unbranching nodes, these heights all correspond to “events”: either a bifurcation or a character state change.

# Finally, I'll proceed up the tree from root to tips, and at each event I'll count the number of edges in each state. This'll be fun.




```

```{r}

```

```{r}

## convert to tree with unbranching nodes
tt<-map.to.singleton(legumes.maps[[1]])
## compute all node heights
H<-nodeHeights(tt)
## pull out heights all all events
h<-max(H)-branching.times(tt)
## get the states at each event
ss<-setNames(as.factor(names(tt$edge.length)),
    tt$edge[,2])
## create a matrix to count lineages
lineages<-matrix(0,length(h),length(levels(armature)),
    dimnames=list(names(h),levels(armature)))
## count them
for(i in 1:length(h)){
    ii<-intersect(which(h[i]>H[,1]),which(h[i]<=H[,2]))
    lineages[i,]<-summary(ss[ii])
}
## sort by event
ii<-order(h)
times<-h[ii]
lineages<-lineages[ii,]

# Now that we're done with that, why don't we proceed to plot our lineages through time by state.

# Here, I'll also overlay a plot of our tree with the mapped character, just so we can see that what we've done was correct. I'll also drop lines from all the changes (but not speciation events) from the position of the change on the tree to the horizontal axis – so we can see how they line up with shifts on our lineages through time plot!


## create plot area
plot(NA,xlim=range(times),ylim=c(0,max(lineages)),
    xlab="time",ylab="lineages",bty="n",las=1)
## add lineages through time for each type
lines(times,lineages[,1],type="s",lwd=3,col=palette()[4])
lines(times,lineages[,2],type="s",col=palette()[2],lwd=3)
## superimpose tree
cols<-setNames(make.transparent(palette()[c(4,2)],0.5),
    levels(armature))
plot(legumes.maps[[1]],cols,ftype="off",add=TRUE,lwd=1,
    mar=c(5.1,4.1,4.1,2.1))
obj<-markChanges(legumes.maps[[1]],plot=FALSE)
for(i in 1:nrow(obj)) lines(rep(obj[i,"x"],2),c(0,obj[i,"y"]),
    lty="dotted",col=make.transparent("grey",0.8))
legend("topleft",c("trait1","rtrait2"),
    pch=22,pt.bg=palette()[c(4,2)],pt.cex=1.2,cex=0.8,
    bty="n")
	

```

```{r}

```

```{r}
# Great. So far, so good.

# Next, let's try this across our whole set of trees.

# To do this, I'm going to create a temporary function (foo), containing our code from above, and then just iterate it across our set of trees.


foo<-function(tree,x){
    tt<-map.to.singleton(tree)
    H<-nodeHeights(tt)
    h<-max(H)-branching.times(tt)
    ss<-setNames(as.factor(names(tt$edge.length)),
        tt$edge[,2])
    lineages<-matrix(0,length(h),length(levels(x)),
        dimnames=list(names(h),levels(x)))
    for(i in 1:length(h)){
        ii<-intersect(which(h[i]>H[,1]),which(h[i]<=H[,2]))
        lineages[i,]<-summary(ss[ii])
    }
    ii<-order(h)
    times<-h[ii]
    lineages<-lineages[ii,]
    list(times=times,ltt=lineages)
}
ltts<-lapply(lizard.maps,foo,x=habitat)


# We can even then plot our results.

plot(NA,xlim=range(sapply(ltts,function(x) range(x$times))),
    ylim=c(1,max(sapply(ltts,function(x) max(x$ltt)))),
    xlab="time",ylab="lineages",bty="n",las=1,log="y")
for(i in 1:length(ltts)){
    lines(ltts[[i]]$times,ltts[[i]]$ltt[,1],type="s",lwd=3,
        col=make.transparent(palette()[4],0.1))
    lines(ltts[[i]]$times,ltts[[i]]$ltt[,2],type="s",
        col=make.transparent(palette()[2],0.1),lwd=3)
}
legend("topleft",c("non-rock-dwelling","rock-dwelling"),
    pch=15,col=palette()[c(4,2)],pt.cex=1.2,cex=0.8,
    bty="n")
	
	
# That part was easy. Now, we want to average across this set of lineage through time plots.

# The problem here is that the positions of our events are different between our different mapped trees!

# My solution is to finely segment the height zero through the total height of the tree, and then proceed across these time slices and count how many lineages (on average) are in each state across all of my trees.

## set times
TIMES<-seq(0,max(H),length.out=10000)
## create matrix for lineages
LINEAGES<-matrix(0,length(TIMES),length(levels(habitat)))
## iterate over times and ltts
for(i in 1:length(TIMES)){
    for(j in 1:length(ltts)){
        ii<-which(ltts[[j]]$times<=TIMES[i])
        ADD<-if(length(ii)==0) rep(0,length(levels(habitat))) else 
            ltts[[j]]$ltt[max(ii),]/length(ltts)
        LINEAGES[i,]<-LINEAGES[i,]+ADD
    }
}
## create empty plot
plot(NA,xlim=range(sapply(ltts,function(x) range(x$times))),
    ylim=c(1,max(sapply(ltts,function(x) max(x$ltt)))),
    xlab="time",ylab="lineages",bty="n",las=1)
## add all ltts
for(i in 1:length(ltts)){
    lines(ltts[[i]]$times,ltts[[i]]$ltt[,1],type="s",lwd=1,
        col=make.transparent(palette()[4],0.05))
    lines(ltts[[i]]$times,ltts[[i]]$ltt[,2],type="s",
        col=make.transparent(palette()[2],0.05),lwd=1)
}
## finish with averaged ltt
lines(TIMES,LINEAGES[,1],lwd=4,col=palette()[4])
lines(TIMES,LINEAGES[,2],lwd=4,col=palette()[2])
legend("topleft",c("non-rock-dwelling","rock-dwelling"),
    pch=15,col=palette()[c(4,2)],pt.cex=1.2,cex=0.8,
    bty="n")
	
	
# Lastly, let's overlay our average lineage through time (by state) with a "densityMap" style visualization of the posterior probability (from stochastic mapping) of being in each state along each edge of the phylogeny.

# For this one, I'm also going to throw in “total lineages” – in addition to the average counts for each state.

# This solution is a bit hacky, so I'll leave it to the reader to figure out!

par(mar=c(5.1,4.1,2.1,2.1))
plot(NA,xlim=range(sapply(ltts,function(x) range(x$times))),
    ylim=c(1,76),
    xlab="time (since the root)",ylab="lineages",bty="n",las=1,
    cex.axis=0.8)
dMap<-densityMap(lizard.maps,plot=FALSE)

dMap<-setMap(dMap,palette()[c(4,2)])
plot(dMap$tree,dMap$cols,0.5,lwd=2,ftype="off",add=TRUE,
    mar=par()$mar,tips=setNames(1:76,lizard.tree$tip.label))
polygon(par()$usr[c(1,2,2,1)],par()$usr[c(3,3,4,4)],
    border="transparent",col=make.transparent("white",0.4))
plot.window(xlim=range(sapply(ltts,function(x) range(x$times))),
    ylim=c(1,76))
lines(TIMES,LINEAGES[,1],lwd=7,col="white")
lines(TIMES,LINEAGES[,1],lwd=3,col=palette()[4])
lines(TIMES,LINEAGES[,2],lwd=7,col="white")
lines(TIMES,LINEAGES[,2],lwd=3,col=palette()[2])
lines(TIMES,rowSums(LINEAGES),lwd=7,type="s",col="white")
lines(TIMES,rowSums(LINEAGES),lwd=3,type="s",col="black")
legend("topleft",c("all lineages","non-rock-dwelling","rock-dwelling"),
    pch=15,col=palette()[c(1,4,2)],pt.cex=1.5,cex=0.8,
    bty="n")
```
