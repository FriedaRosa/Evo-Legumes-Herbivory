---
title: "Quarto_Mammals_CTT"
author: "Friederike Wölke"
format: html
editor: visual
---

# Open the required Libraries

```{r}
#| warning = F
#| message = F

rm(list=ls())


# Libraries:

library(phangorn) # to compute MCC tree
library(evobiR) # reorder data by tree

library(phytools) # v. ‘1.9.16’ for phylo stuff
library(dplyr) # for data handling
library(evobiR) # v. ‘1.1’ To reorder data based on tree
library(geiger) # v. ‘2.0.11’ for Mk Models
library(tictoc) # for time measurements of computations
library(tidyr) # data handling
library(ggplot2)
library(viridis)


```

# My Data (Mammals): \* read back from .rds

```{r}
#| label: Mammals data & produce simmap




# Data & Tree:
traitData <- read.csv("../input/Mammals/Trait_data.csv")
tree <- read.nexus("../input/Mammals/mammal_MCC.nex")

# Make MCC tree:
MCC <- mcc(tree, tree = TRUE, part = NULL, rooted = TRUE)

# make dataframe with species, mass  trait
df1 <- traitData[,c(1,6,12,20)] #Terrestrial, Mass.g, Diet.Plant
subset_df <- df1[df1[, 2] == 1, ] # Terrestrial = 1

# Initialize a new column filled with zeros
subset_df$Condition_Met <- 0 

# Update this column to 1 for animals that meet both conditions (mass >= 10000 and diet >= 95)
subset_df$Condition_Met[subset_df$Mass.g >= 10000 & subset_df$Diet.Plant >= 95] <- 1


mammal_traits <- subset_df[,c(1,5)]
write.csv(mammal_traits, file = "../output/CSV/mammal_traits.csv", row.names = FALSE)


## Match Data & Tree:
tree2 <- ladderize(MCC)

row.names(mammal_traits) <- mammal_traits$Binomial.1.2
sp_drop <- setdiff(tree2$tip.label, mammal_traits$Binomial.1.2)

# Drop these species from the tree, because we need matching data between tree and traits
tree3 <- drop.tip(tree2, sp_drop)
tree4 <- ladderize(tree3)

matches <- match(mammal_traits$Binomial.1.2, tree4$tip.label, nomatch = 0)
mammal_traits2 <- subset(mammal_traits, matches != 0)
data2 <- ReorderData(tree4, mammal_traits2, taxa.names = "row names")
dd3 <- data2
tree <- tree4

# Trait Vector:
Mass <- numeric(length = nrow(dd3))
unique(dd3$Condition_Met)
# Create the 'Mass' factor based on the 'Condition_Met' column
Mass <- ifelse(dd3$Condition_Met == 0, "other", "megaherbivore")
str(Mass)
head(Mass)
table(Mass)

# Convert to a factor
Mass <- as.factor(Mass)

# Display the levels of Mass to confirm
print(levels(Mass))

# Reorder data if needed (assuming ReorderData and tree2 are defined)
Mass <- ReorderData(tree, Mass, taxa.names="names")
names(Mass) <- rownames(dd3)
# ordered trait vector for models (not dataframe)
str(Mass) # make sure it's a factor


trait <- Mass

# Mk models ============================
# estimate the rates of transitioning between ancestral states given a hypothesis (either equal rates(ER), or different rates(ARD))

# computing time = 2.297s
system.time(
  equal <- fitDiscrete(tree, trait, model = "ER"), gcFirst = T
)

# computing time = 8.726s
system.time(
  ard <- fitDiscrete(tree, trait, model = "ARD")
)

# Calculate AIC weights
aic.discrete <- setNames(c(equal$opt$aic, ard$opt$aic), c("equal", "different"))
weights <- aicw(aic.discrete)
weights # ARD model performs better for megaherbivore/no other


# For 100 simulation (nsim=100) --> computing time = 147.31s
system.time(
  mtrees <- make.simmap(tree, trait, model = "ARD", nsim = 100)
)
saveRDS(mtrees, "../output/RDS/Mammals_mtrees_multiSimmap.rds")

```



# My adaptation of ctt() function

```{r}
mtrees <- readRDS("../output/RDS/Mammals_mtrees_multiSimmap.rds")

### Required function ========================================================================== #
getChanges<-function(tree){
  states<-sort(unique(getStates(tree)))
  nc<-sapply(tree$maps,length)-1
  b<-which(nc>0)
  nc<-nc[b]
  xx<-vector()
  H<-nodeHeights(tree)
  for(i in 1:length(b)){
    for(j in 1:nc[i]){
      ss<-names(tree$maps[[b[i]]])[j+1]
      x<-rep(H[b[i],1]+cumsum(tree$maps[[b[i]]])[j],2)
      xx<-c(xx,setNames(x[1],
                        paste(names(tree$maps[[b[i]]])[j:(j+1)],
                              collapse="->")))
    }
  }
  xx
}



# ============================================================================================= #
# Create a function to find the segment ID for a given time value:
# ============================================================================================= #

find_segment_id <- function(time) {
  segment_indices <- cut(time, breaks = segs_df[, 2], labels = FALSE)
  return(segs_df$segsID[segment_indices])
}

## ============================================================================================= #


  # ================================================================= #
  # Working the multiSiammp
  # ================================================================= #

  
  
  # Get all changes from all simulations so that we can loop through them:
  changes <- sapply(mtrees, getChanges) 
  
  
  # Transform the original changes list of matrices from sapply() for all simulations to dataframe 
  # add trans_no to each transition based on grouping by transition 
  # (i.e, there are two trans_no = 1, one for each transition type)
  
  i_changes_list <- list() 
  for (i in 1:length(changes)) {
    
    i_changes <- changes[[i]] # for each simulation from multiSimmap
    
    
    # extract transition types and times and assign ID column for simmap simulation
    i_changes_df <- data.frame(transition = names(i_changes), time = i_changes, N_sim = i)
    i_changes_df$transition <- as.factor(i_changes_df$transition)
    
    # Add trans_no to each transition from a group (transition type)
    i_changes_df <- i_changes_df %>%  arrange(time) %>%
      group_by(transition) %>%
      mutate(trans_no = row_number())
    
    i_changes_list[[i]] <- i_changes_df
    
  }
  
  # Final Table without edge.lengths:
  changes_table <- plyr::rbind.fill(i_changes_list, fill=T)
  changes_table_wo_edge <- changes_table


  
# ====================================================================================================== #
## Step 1: Loop over each simulation and extract 
# - breaks for segments
# - edge.lengths
# - rates for each character state transition
# ====================================================================================================== #


object_list <- list()
rates_list <- list()



# First Level of the loop  
for (Nsimulation in 1:100){ 
  
  
  # ====================================================================================================== #
  # Setting global variables for the Analysis
  # ====================================================================================================== #
  
  # set the number of time-segments for which everything will be calculated:
  b <- 20    
  
  # reduce to one tree to extract parameters from each simulation separately:
  tree <- as.phylo(mtrees[[Nsimulation]])
  
  # extract time since root
  h <- max(nodeHeights(tree))
  
  # calculate the time segments based on time since the origin and the time segments that were set by the user
  segs <- cbind(seq(0,h-h/b,h/b),
              seq(1/b*h,h,h/b))

  
  # ====================================================================================================== #
  # Transitions & Timing  (getChanges)
  # ====================================================================================================== #
  
  
  # ================================================================= #
  # Working changes from each simmap simulation separately:
  # ----------------------------------------------------------------- #
  # Changes per Segments:
  # ================================================================= #
  

# Loop through all changes & Calculate average number of changes per time interval (segs; set with "b")
  
  nchanges<-rep(0,b)
  for(i in 1:length(changes)) { # loop through all simulations from simmap  

# loop through all individual changes from one simmap simulation and calculate relative changes per time segment
# nchanges = collects the relative number of changes (of all changes) per segment
    
    for(j in 1:length(changes[[i]])) { 
      
      ind<-which((changes[[i]][j]>segs[,1])+ 
                   (changes[[i]][j]<=segs[,2])==2)
      nchanges[ind]<-nchanges[ind]+1/length(changes)
      
      } # closing of 2nd level
    
    } # closing of 1st level

  rm(i,j)  
  
  
  # ================================================================= #
  # Working changes from each simmap simulation separately:
  # ----------------------------------------------------------------- #
  # Edge Lengths per Segments:
  # ================================================================= #

  # Edge.Lengths = Number of species in the phylogeny per time slot (increases naturally with time)
  # ! Note: has to be accounted for when showing transition rates
  # Here we calculate edge lengths for each segement separatly:
  
  # -------------------------------------------------------------------------------------------------------- #
  
  # Compute Lineages-Through-Time with ltt() function from the phytools package to extract edge.lengths from
  LTT <- ltt(tree,plot=FALSE)

	# transform LTT data so that we can use it:
  LTT <- cbind(LTT$ltt[2:(length(LTT$ltt)-1)],                # Number of species at each node minus the root
               LTT$times[2:(length(LTT$ltt)-1)],              # "start" time for each node minus the root
               LTT$times[3:length(LTT$ltt)])                  # "end" time for each node minus the root
  
  # -------------------------------------------------------------------------------------------------------- #
  
  ## Now we loop through all segments to extract matching edge.lengths =================================== #
  
  # set count variable:
	ii<-1

	# Create an empty vector to store edge lengths
	edge.length <- rep(0, nrow(segs))

	
	# 2nd level loop: 
	# (for one tree because LTT is calculated for one tree)
   for (i_segs in 1:nrow(segs)) {
     

     # Find the indices of LTT segments that overlap with the current segs segment
     overlap_indices <- which(LTT[, 2] <= segs[i_segs, 2] & LTT[, 3] >= segs[i_segs, 1])
  

     # Calculate edge length for the current segs segment using vectorized operations
     # 3rd level loop: 
     for (ii in overlap_indices) {
     
       # edge.length should contain the edge lengths for all segments:  
       edge.length[i_segs] <- edge.length[i_segs] +        
         LTT[ii, 1] * # counts number of lineages between time intervals
         (min(segs[i_segs, 2], LTT[ii, 3]) - # end time interval
            max(segs[i_segs, 1], LTT[ii, 2]))  # start time interval

     
       } # 3rd level closing
     
   } # 2nd level closing
	
	
	edge.length_backup <- edge.length
	edge.length <-c(1, edge.length)
  # edge.length should contain the edge lengths for all segments in a given simulation
 	
	# adding segsID coulmn to edge lengths:
	edge.length_df <- data.frame(edge.length = edge.length, segsID = seq(1,b+1))
	
	
	#########################################################################################################
	# WIP: 
	#########################################################################################################
	
	
	
	# ================================================================= #
  # Working the multiSimmap:
  # ----------------------------------------------------------------- #
  # Edge Lengths at each transition event
  # ================================================================= #
	## Adapted code from the segments by me
	
	# we need the table for all simmaps: changes_table so that we can loop through it
	
	# set count variable:
	ii<-1

	# Create an empty vector to store edge lengths
	edge.length_transitions <- rep(0, nrow(changes_table))
  edge.lengths_all <- list()
	changes_times <- changes_table$time
	
	
	# 2nd level loop: 
	# (for one tree because LTT is calculated for one tree)
   for (i_changes in 1:nrow(changes_table)) {

     # Find the indices of LTT segments that overlap with the current segs segment
     
     # "which start times of the Lineages are smaller or equal to the time the change happened and which end times of the lineages are larger or equal to the time the change happend."
     # --> this gives the node numbers that were there when the transition happend
     
     overlap_indices <- which(LTT[, 2] <= changes_times[i_changes] & LTT[, 3] >= changes_times[i_changes])
  

     # Calculate edge length for the current segs segment using vectorized operations
     # 3rd level loop: 
     
     for (ii in overlap_indices) { # ii = number of lineages when a transition occurred
     
       # edge.length should contain the edge lengths for all segments:  
       edge.length_transitions[i_changes] <- edge.length_transitions[i_changes] +        
         LTT[ii, 1] 
       
       edge.length_transitions2 <- data.frame(time = changes_times[i_changes], edge.length = edge.length_transitions[i_changes])

     
       edge.lengths_all[[i_changes]] <- edge.length_transitions2
       
       } # 3rd level closing
     
   } # 2nd level closing
	
  
  edge.lengths_all_df <- plyr::rbind.fill(edge.lengths_all)
  changes_table_w_edge <- merge(changes_table_wo_edge, edge.lengths_all_df, by = "time")
  # Write to file (once is enough)
  write.csv(changes_table_w_edge, "../output/CSV/Mammals_changes_table_w_edgelengths.csv")
	
#########################################################################################################
# END WIP 
#########################################################################################################
	
     	  
# ============================================================================================= #
# Create a dataframe with transitions, times, edge.lengths, segment IDs.
# ============================================================================================= #
	  
  ## We are here = first level loop: along simulations
	  
	 	# Again extract changes for each simulation separately:
	  current_simulation <- as.data.frame(changes[[Nsimulation]], 
	                                      row.names = names(changes[[Nsimulation]]))
	  names(current_simulation) <- c("time")
	  current_simulation$transition <- rownames(current_simulation)
	 	current_simulation$N_sim <- Nsimulation
	 	current_simulation <- current_simulation %>% arrange(time)
	 	current_simulation$IDtransition <- seq(1:nrow(current_simulation))

	 	
	 	# ============================================================================================= #
	 	# Working the segments: 
	 	# ============================================================================================= #

	 	
	 	# Create a vector of segment IDs
	 	segs_df <- as.data.frame(segs)
	 	new_row <- data.frame(V1 = 0, V2 = 0)
	 	segs_df <- rbind(new_row, segs_df)
	 	segs_df$segsID <- seq(1,b+1) # now we can calculate the breaks from it

	 	# Use the apply function to find the segment ID for each row in current_simulation
	 	current_simulation$segsID <- apply(current_simulation, 1, function(row) {
  
	 	  time <- as.numeric(row["time"])
	 	  return(find_segment_id(time))

	 	  }) # closing loop from within the apply-function (2nd level loop closing)

	
	 	# assign edge.length based on segment ID
	 	current_simulation <- unique(merge(current_simulation, edge.length_df, by="segsID", all = T))
	 	names(segs_df) <- c("segs_start", "segs_end", "segsID")
	  current_simulation <-	unique(merge(current_simulation, segs_df, by = "segsID", all = T))
	 	
	  # Calculate rate for each simulation:
	 	current_simulation_rates <- current_simulation %>% 
	 	  group_by(segsID, N_sim, transition) %>% 
	 	  mutate(Nchanges = length(!is.na(IDtransition))) %>% 
	 	  mutate(rate = Nchanges / edge.length)

	 rates_list[[Nsimulation]] <- current_simulation_rates
	  
	 object <-list(segments=segs, 
	               nchanges=nchanges, 
	               edge.length=edge.length[-1], 
	               tree=tree)
	 
	class(object)<-"ctt"
	object_list[[Nsimulation]] <- object 
	  
} # 1st level closing

toc()  # 3524.13524.1 sec elapsed = 58 min

class(object_list) <-"multiCtt"

save.image("~/GitHub/Evo-Legumes-Herbivory/LegumesArmature/output/RData/Mammals_rates_ws.RData")
```



```{r}

load("../output/RData/Mammals_rates_ws.RData")

rates_df <- plyr::rbind.fill(rates_list)
summary(rates_df)

# Your data manipulation code
rates_df <- rates_df %>%
  group_by(N_sim, segsID, transition) %>%
  mutate(rate = ifelse(is.na(transition), 0, rate),
         Nchanges = ifelse(is.na(transition), 0, Nchanges),
         segs_mean = (segs_end+ segs_start)/2) %>% # Adjust the threshold (1e-6) as needed
  mutate(avg_time = ifelse(Nchanges == 1, time, mean(time))) %>% 
  mutate(avg_time = ifelse(is.na(avg_time), segs_mean, avg_time)) %>%
  arrange(segsID) %>% unique()

```


## to do: post-processing - Create rows for rate =  0

```{r}
# Replace NAs in Transition types to set the rates to 0 where no transition occurred:
rates_df_copy <- rates_df

# Replace "NA" with the first transition type
rates_df_copy$transition[is.na(rates_df_copy$transition)] <- unique(rates_df_copy$transition)[[2]]

# Create a second copy of the data frame with "NA" transitions
rates_df_copy2 <- rates_df

# Replace "NA" with the second transition type
rates_df_copy2$transition[is.na(rates_df_copy2$transition)] <- unique(rates_df_copy2$transition)[[3]]

# Combine the two copies to get the final data frame with replicates
final_df <- bind_rows(rates_df_copy, rates_df_copy2)


########## ====================================================================================== ####
# Specify the transition type for which you want to ensure rates
specific_transition_type <- unique(rates_df_copy$transition)[[2]]

# Generate a data frame with all possible combinations of segsID and the specific transition type
all_combinations <- expand_grid(
  segsID = unique(final_df$segsID),
  transition = specific_transition_type
)

# Left join the generated data frame with the original data frame
final_df1 <- all_combinations %>%
  left_join(final_df, by = c("segsID", "transition")) %>%
  mutate(rate = ifelse(is.na(rate), 0, rate))# Generate a data frame with all possible combinations of segsID and the specific transition type
all_combinations <- expand_grid(
  segsID = unique(final_df1$segsID),
  transition = specific_transition_type
)

# Left join the generated data frame with the original data frame
final_df1 <- all_combinations %>%
  left_join(final_df1, by = c("segsID", "transition")) %>%
  mutate(rate = ifelse(is.na(rate), 0, rate))
########## ====================================================================================== ####
# Specify the transition type for which you want to ensure rates
specific_transition_type <- unique(rates_df_copy$transition)[[1]]

# Generate a data frame with all possible combinations of segsID and the specific transition type
all_combinations2 <- expand_grid(
  segsID = unique(final_df$segsID),
  transition = specific_transition_type
)

# Left join the generated data frame with the original data frame
final_df2 <- all_combinations2 %>%
  left_join(final_df, by = c("segsID", "transition")) %>%
  mutate(rate = ifelse(is.na(rate), 0, rate))# Generate a data frame with all possible combinations of segsID and the specific transition type

all_combinations2 <- expand_grid(
  segsID = unique(final_df2$segsID),
  transition = specific_transition_type
)

# Left join the generated data frame with the original data frame
final_df2 <- all_combinations2 %>%
  left_join(final_df2, by = c("segsID", "transition")) %>%
  mutate(rate = ifelse(is.na(rate), 0, rate))
########## ====================================================================================== ####



# Sort the data frame if needed
final_df <- final_df %>% arrange(segsID)  # You can specify the sorting order

# Now final_df contains rows with "NA" in the "transition" column replaced by two different transition types.







# Your ggplot code
ggplot(final_df, aes(y = rate, x = segs_end, col = factor(transition), group = factor(transition))) +
  #geom_point() +
  geom_line() +
  ylim(0, 0.015)+
  theme_light()+
  scale_color_viridis(discrete=T)



ggplot(final_df, aes(y = rate, x = segs_end, fill = factor(transition))) +
  geom_col(position = "identity")+
  ylim(0, 0.015)+
  theme_light()+
  scale_fill_viridis(discrete=T, alpha = 0.4)
```

```{r}

## below adapted from other script:  https://github.com/rubysaltbush/pollination-macroevolution/blob/main/scripts/analysis/simmap.R


megaherbivore_transitions <- rates_df


# build new data frame with cumulative number of transitions
megaherbivore_trans_cumul <- data.frame()
for(n in 1:100){
  trans <- megaherbivore_transitions %>% ungroup() %>%
    dplyr::filter(N_sim == n) %>%
    dplyr::group_by(transition) %>%
    dplyr::mutate(trans_no = row_number(N_sim))
  
  megaherbivore_trans_cumul <- rbind(megaherbivore_trans_cumul, trans)
}
rm(n, trans)




# =========================================================================================================== #
#  Now we are summarizing over the 100 simulations:
# =========================================================================================================== #
##### copied from somewhere else in the code from the same script....:


# first need to know average number of transitions and across simulations, rounded. 
trans_avg_length <- megaherbivore_trans_cumul %>%
  dplyr::group_by(transition, N_sim) %>%
  dplyr::mutate(no_trans = max(trans_no)) %>%
  dplyr::ungroup() %>%
  dplyr::filter(trans_no == no_trans) %>%
  dplyr::group_by(transition) %>%
  dplyr::mutate(avg_length = round(mean(no_trans), digits = 0)) %>%
  dplyr::select(transition, avg_length) %>%
  dplyr::ungroup() %>%
  dplyr::distinct()

# now knowing this, can rearrange data and average times and edge.lengths across rows
avg_trans_times <- megaherbivore_trans_cumul %>%
  dplyr::group_by(transition, trans_no) %>%
  dplyr::mutate(avg_time = mean(time)) %>%
  dplyr::mutate(SE_time = sqrt(var(time) / length(time)),
                avg_edge.length = mean(edge.length)) %>% ungroup() %>%
  group_by(N_sim, segsID, transition) %>%
  mutate(avg_Nchanges = mean(Nchanges)) %>%
  dplyr::select(transition, trans_no, avg_time, SE_time, avg_edge.length, avg_Nchanges) %>%
  dplyr::distinct()

# reduce avg_trans_times to trans_avg_length
avg_trans_times_a2na <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
avg_trans_times_na2a <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])
avg_trans_times <- rbind(avg_trans_times_a2na, avg_trans_times_na2a)
rm(avg_trans_times_a2na, avg_trans_times_na2a)

# export these results to csv in case I need them
readr::write_csv(avg_trans_times, "../output/CSV/mean_transition_times_megaherbivore_MCC.csv")



#### Plotting ======================================

# install.packages("prettyGraphs") #to set transparancy of colors with "alpha"
library(prettyGraphs)

myColours = c("lightgrey", "#FFBB00")
myColoursAlpha <- add.alpha(myColours, alpha=0.4)
my_cols <- setNames(myColoursAlpha, c("megaherbivore->other", "other->megaherbivore"))

pdf("../output/Figs/megaherbivore_transition_times_mean_hist.pdf", height = 2.8, width = 6)
min <- min(avg_trans_times$avg_time)
max <- max(avg_trans_times$avg_time)
ax <- pretty(min:230, n = 20)

mega_to_no_mega <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::mutate(mega_to_no_mega = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(mega_to_no_mega)

no_mega_to_mega <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::mutate(no_mega_to_mega = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(no_mega_to_mega)

a2na <- hist(mega_to_no_mega$mega_to_no_mega, breaks = ax, plot = FALSE)
na2a <- hist(no_mega_to_mega$no_mega_to_mega, breaks = ax, plot = FALSE)

plot (a2na, col = myColours[1], xlab = "Time of transitions (mya)",  
      main = "", ylab = "number of transitions", 
      ylim = c(0, 100), xlim = c(220,0)) # alter if x values change!
plot (na2a, col = my_cols[2], add = TRUE)


# data for density graph
mega_to_no_mega <- megaherbivore_transitions %>% ungroup() %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::mutate(mega_to_no_mega = time,
                rate_mega_to_no_mega = rate) %>%
  dplyr::select(mega_to_no_mega, rate_mega_to_no_mega, simulation = N_sim)
no_mega_to_mega <- megaherbivore_transitions %>% ungroup() %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::mutate(no_mega_to_mega = time,
                rate_no_mega_to_mega = rate) %>%
  dplyr::select(no_mega_to_mega, rate_no_mega_to_mega, simulation = N_sim)

# Plot density of transitions ==================================================================== #
# calculate density curve
density_a2na <- density(mega_to_no_mega$mega_to_no_mega)
density_na2a <- density(no_mega_to_mega$no_mega_to_mega)

# plot the density
plot(density_a2na, lwd = 2, col = myColours[1], 
     xlim = c(220,0), xlab = "Time of transitions (mya)", bty = "l", ylim=c(0, 0.2),
     cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
lines(density_na2a, lwd = 2, col = myColours[2], xlim = c(220,0))
dev.off()

# Plot density of rate: ========================================================================== #
# # calculate density curve
# density_a2na_rate <- density(mega_to_no_mega$rate_mega_to_no_mega)
# density_na2a_rate <- density(no_mega_to_mega$rate_no_mega_to_mega)
# 
# plot(density_a2na_rate, lwd = 2, col = myColours[1], 
#      xlim = c(0,0.15), xlab = "Relative Transitions", bty = "l", ylim=c(0, 170),
#      cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
# lines(density_na2a_rate, lwd = 2, col = myColours[2], xlim = c(0,0.15))
# 
# # add data-points with noise in the X-axis
# rug(jitter(no_mega_to_mega$rate_no_mega_to_mega), col = my_cols[1])
# rug(jitter(mega_to_no_mega$rate_mega_to_no_mega), col = my_cols[2])


##################

pdf("../output/Figs/RatesPlot.pdf", height = 8, width = 10)
par(mar = c(5.1, 5.1, 4.1, 2.1))    # increase margins

mega_to_no_mega <- megaherbivore_trans_cumul %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  mutate(rate_mega_to_no_mega = rate)

# first set up basic plot parameters
plot(mega_to_no_mega$rate_mega_to_no_mega ~ mega_to_no_mega$time,
     type = "p", bty = "l", 
     xlim = c(50,0), ylim = c(0,1),
     col = my_cols[1], pch = 15,
     xlab = "Time of transitions (mya)", 
     ylab = "Cumulative number of transitions",
     cex.lab = 1.8, cex.axis = 1.8)

# then loop through all data and add all points and lines to plot for 1000 simulations
for(n in 1:100){
  
  no_mega_to_mega <- megaherbivore_transitions %>%
    dplyr::filter(transition == "other->megaherbivore") 
    
  mega_to_no_mega <- megaherbivore_transitions %>%
    dplyr::filter(transition == "megaherbivore->other") 
  
  
  points(mega_to_no_mega$rate ~ mega_to_no_mega$time, 
         col = my_cols[1], pch = 15)
  lines(mega_to_no_mega$rate ~ mega_to_no_mega$time, 
        col = my_cols[1])
  points(no_mega_to_mega$rate ~ no_mega_to_mega$time, 
         col = my_cols[2], pch = 17)
  lines(no_mega_to_mega$rate ~ no_mega_to_mega$time, 
        col =my_cols[2])
}

# then add average points and line in blue
# first prep data
no_mega_to_mega <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
mega_to_no_mega <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])

# then add to plot
points(mega_to_no_mega$trans_no/mega_to_no_mega$avg_edge.length ~ mega_to_no_mega$avg_time,
       col = "blue", pch = 15)
lines(mega_to_no_mega$trans_no/mega_to_no_mega$avg_edge.length ~ mega_to_no_mega$avg_time, 
      col = "blue")
points(no_mega_to_mega$trans_no/no_mega_to_mega$avg_edge.length ~ no_mega_to_mega$avg_time,
       col = "darkblue", pch = 17)
lines(no_mega_to_mega$trans_no/no_mega_to_mega$avg_edge.length ~ no_mega_to_mega$avg_time, 
      col = "darkblue")

# add legend
legend("topleft",
       legend = c("megaherbivore->other", "other->megaherbivore"),
       col = c(my_cols[1],my_cols[2]),
       pch = c(15, 17), pt.lwd = 0.001, bty = "n", cex = 1.8)
dev.off()

```


```{r}

#| label: Modified Fig4 Pollination Study

## Ref[1], Ref[0] -> Ref[2]
transition_times <- function(simmap) {
  # below adapted from Liam Revells' phytools blog 
  # http://blog.phytools.org/2015/08/getting-timing-of-trait-changes-from.html
  # extracts raw transition times from a simmap (collapses multiple transitions
  # down into single transition events)
  # get tips and their states
  x <- phytools::getStates(simmap,"tips")
  # get unique states
  states <- sort(unique(x))
  # get length of states
  m <- length(states)
  # below makes a little matrix describing transitions
  ct <- sapply(states, 
               function(x,y) sapply(y, function(y,x) paste(x,"->", y, sep=""), 
                                    x = x), y = states)
  rm(x, states)
  # then a matrix to invalidate self->self transitions
  ii <- matrix(TRUE, m, m)
  diag(ii) <- rep(FALSE, m)
  # then a list to store results in
  changes <- vector(mode="list", length = m*(m - 1))
  rm(m)
  # named by types of transitions
  names(changes) <- as.vector(ct[ii])
  rm(ct, ii)
  # then singling out maps where transitions happen (where there is more than 1 state)
  nc <- sapply(simmap$maps, length) - 1
  ind <- which(nc > 0)
  nc <- nc[ind]
  
  # getting the node heights (measure of time/branch lengths) across the tree
  H <- phytools::nodeHeights(simmap)
  maps <- simmap$maps[ind]
  # then looping through and calculating the node heights of each transition
  for(i in 1:length(maps)){
    for(j in 1:nc[i]){
      sc <- paste(names(maps[[i]])[j:(j + 1)], collapse = "->")
      h <- H[ind[i], 1] + cumsum(maps[[i]])[j]
      changes[[sc]] <- c(changes[[sc]], as.numeric(h))
    }
  }
  rm(nc, ind, h, H, i, j, sc, maps)
  # removing any nulls from list of changes and sorting small to large
  changes <- changes[!sapply(changes, is.null)]
  changes <- lapply(changes, sort, decreasing = FALSE)
  
  # now convert this changes list into nice data frame output
  output <- data.frame()
  for(i in 1:length(changes)){
    df <- dplyr::bind_cols(changes[i])
    df <- df %>%
      mutate(transition = colnames(df)) %>%
      rename(nodeheight = 1)
    output <- rbind(output, df)
  }
  
  # node heights are the height above the root, so time but inverse along the tree
  # to get time from node heights need to subtract from max height of tree
  output$time <- max(nodeHeights(simmap)) - output$nodeheight
  
  # get rid of nodeheight column
  output <- output[-1]
  
  # and return the output! to graph etc.
  output
}

# End of function ====================================================================================== #

# Ref[0] -> Ref[3]

mtrees <- readRDS("../output/RDS/Mammals_mtrees_multiSimmap.rds")

# apply function across list of multiple simulations:

megaherbivore_transitions <- data.frame()
for(i in 1:length(mtrees)){
  temp <- cbind(i, transition_times(mtrees[[i]]))
  megaherbivore_transitions <- rbind(megaherbivore_transitions, temp)
}
rm(temp, i)

table(megaherbivore_transitions$transition)

# build new data frame with cumulative number of transitions
megaherbivore_trans_cumul <- data.frame()
for(n in 1:100){
  trans <- megaherbivore_transitions %>%
    dplyr::filter(i == n) %>%
    dplyr::group_by(transition) %>%
    dplyr::mutate(trans_no = row_number(i))
  
  megaherbivore_trans_cumul <- rbind(megaherbivore_trans_cumul, trans)
}
rm(n, trans)


##### copied from somewhere else in the code from the same script....:

# first need to know average number of transitions, rounded
trans_avg_length <- megaherbivore_trans_cumul %>%
  dplyr::group_by(transition, i) %>%
  dplyr::mutate(no_trans = max(trans_no)) %>%
  dplyr::ungroup() %>%
  dplyr::filter(trans_no == no_trans) %>%
  dplyr::group_by(transition) %>%
  dplyr::mutate(avg_length = round(mean(no_trans), digits = 0)) %>%
  dplyr::select(transition, avg_length) %>%
  dplyr::ungroup() %>%
  dplyr::distinct()

# now knowing this, can rearrange data and average times across rows
avg_trans_times <- megaherbivore_trans_cumul %>%
  dplyr::group_by(transition, trans_no) %>%
  dplyr::mutate(avg_time = mean(time)) %>%
  dplyr::mutate(SE_time = sqrt(var(time) / length(time))) %>%
  dplyr::select(transition, trans_no, avg_time, SE_time) %>%
  dplyr::distinct()

# reduce avg_trans_times to trans_avg_length
avg_trans_times_m2o <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
avg_trans_times_o2m <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])
avg_trans_times <- rbind(avg_trans_times_m2o, avg_trans_times_o2m)
rm(avg_trans_times_m2o, avg_trans_times_o2m)

# export these results to csv in case I need them
readr::write_csv(avg_trans_times, "../Fig4Pollination/Mammals_mean_transition_times_megaherbivore_MCC.csv")



#### Plotting ======================================

# install.packages("prettyGraphs") #to set transparancy of colors with "alpha"
library(prettyGraphs)

myColours = c( "#FFBB00","lightgrey")
myColoursAlpha <- add.alpha(myColours, alpha=0.4)
my_cols <- setNames(myColoursAlpha, c("megaherbivore->other", "other->megaherbivore"))

pdf("../Fig4Pollination/megaherbivore_transition_times_mean_hist.pdf", height = 2.8, width = 6)
min <- min(avg_trans_times$avg_time)
max <- max(avg_trans_times$avg_time)
ax <- pretty(min:106, n = 20)

mega2other <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::mutate(mega2other = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(mega2other)

other2mega <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::mutate(other2mega = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(other2mega)

a2na <- hist(other2mega$other2mega, breaks = ax, plot = FALSE)
na2a <- hist(mega2other$mega2other, breaks = ax, plot = FALSE)

plot (a2na, col = myColours[1], xlab = "Time of transitions (mya)",  
      main = "", ylab = "number of transitions", 
      ylim = c(0, 40), xlim = c(100,0)) # alter if x values change!
plot (na2a, col = my_cols[2], add = TRUE)


# data for density graph
mega2other <- megaherbivore_transitions %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::mutate(mega2other = time) %>%
  dplyr::select(mega2other, simulation = i)
other2mega <- megaherbivore_transitions %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::mutate(other2mega = time) %>%
  dplyr::select(other2mega, simulation = i)

# calculate density curve
density_a2na <- density(mega2other$mega2other)
density_na2a <- density(other2mega$other2mega)

# plot the density
plot(density_a2na, lwd = 2, col = myColours[1], 
     xlim = c(58,0), xlab = "Time of transitions (mya)", bty = "l", ylim=c(0, 0.2),
     cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
lines(density_na2a, lwd = 2, col = myColours[2], xlim = c(58,0))

# add data-points with noise in the X-axis
rug(jitter(mega2other$mega2other), col = my_cols[1])
rug(jitter(other2mega$other2mega), col = my_cols[2])

dev.off()
##################

pdf("../output/Figs/Mammals_RatesPlot.pdf", height = 8, width = 10)
par(mar = c(5.1, 5.1, 4.1, 2.1))    # increase margins

mega2other <- changes_table %>%
  dplyr::filter(transition == "megaherbivore->other")

# first set up basic plot parameters
plot(mega2other$trans_no ~ mega2other$time,
     type = "p", bty = "l", xlim = c(100,0), ylim = c(0,60),
     col = my_cols[1], pch = 15,
     xlab = "Time of transitions (mya)", 
     ylab = "number of transitions",
     cex.lab = 1.8, cex.axis = 1.8)

# then loop through all data and add all points and lines to plot for 1000 simulations
for(n in 1:1000){
  test <- megaherbivore_transitions %>%
    dplyr::filter(i == n) %>%
    dplyr::group_by(transition) %>%
    dplyr::mutate(trans_no = row_number(i))
  
  other2mega <- test %>%
    dplyr::filter(transition == "other->megaherbivore")
  mega2other <- test %>%
    dplyr::filter(transition == "megaherbivore->other")
  
  points(mega2other$trans_no ~ mega2other$time, 
         col = my_cols[1], pch = 15)
  lines(mega2other$trans_no ~ mega2other$time, 
        col = my_cols[1])
  points(other2mega$trans_no ~ other2mega$time, 
         col = my_cols[2], pch = 17)
  lines(other2mega$trans_no ~ other2mega$time, 
        col =my_cols[2])
}

# then add average points and line in blue
# first prep data
other2mega <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
mega2other <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])

# then add to plot
points(mega2other$trans_no ~ mega2other$avg_time,
       col = "blue", pch = 15)
lines(mega2other$trans_no ~ mega2other$avg_time, 
      col = "blue")
points(other2mega$trans_no ~ other2mega$avg_time,
       col = "darkblue", pch = 17)
lines(other2mega$trans_no ~ other2mega$avg_time, 
      col = "darkblue")

# add legend
legend("topleft",
       legend = c("megaherbivore->other", "other->megaherbivore"),
       col = c(my_cols[1],my_cols[2]),
       pch = c(15, 17), pt.lwd = 0.001, bty = "n", cex = 1.8)
dev.off()
```

```{r}

library(ggplot2)
library(viridis)
rates_df %>% ungroup() %>% group_by(N_sim, transition) %>% 
  ggplot(aes(x = segs_end , y = rate, group = as.factor(transition), col = as.factor(transition))) +
  geom_point()+
  geom_line()+
  scale_color_viridis(discrete=T, alpha = 0.6)


## Plots from pollination study:

mega_to_other <- avg_trans_times %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::mutate(mega_to_other = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(mega_to_other)

other_to_mega <- avg_trans_times %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::mutate(other_to_mega = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(other_to_mega)

# calculate density curve
density_m2o <- density(mega_to_other$mega_to_other)
density_o2m <- density(other_to_mega$other_to_mega)

# plot the density
plot(density_m2o, lwd = 2, col = myColours[1], 
     xlim = c(220,0), xlab = "Time of transitions (mya)", bty = "l", ylim=c(0, 0.2),
     cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
lines(density_o2m, lwd = 2, col = myColours[2], xlim = c(220,0))
```


# -- Plot.ctt function --

```{r}
plot.ctt<-function(x,...){
  h<-max(nodeHeights(x$tree))
  args<-list(...)
  if(!is.null(args$type)){ 
    type<-args$type
    args$type<-NULL
  } else type<-"rate"
  if(!is.null(args$show.tree)){
    show.tree<-args$show.tree
    args$show.tree<-NULL
  } else show.tree<-FALSE
  if(!is.null(args$add)){ 
    add<-args$add
    args$add<-NULL
  } else add<-FALSE
  if(is.null(args$ylim)) 
    args$ylim<-if(type=="number")c(0,max(x$nchanges)) else 
      c(0,max(x$nchanges/x$edge.length))
  if(is.null(args$xlim))
    args$xlim<-c(max(x$segments),min(x$segments))
  if(is.null(args$lwd)) args$lwd<-2
  if(is.null(args$xlab)) args$xlab<-"time since the present"
  if(is.null(args$ylab)) 
    args$ylab<-if(type=="number") "mean number of changes" else
      "mean number of changes / total edge length"
  args$type<-"l"
  args$x<-h-as.vector(t(x$segments))
  args$y<-if(type=="number") rbind(x$nchanges,x$nchanges) else 
    rbind(x$nchanges/x$edge.length,x$nchanges/x$edge.length)
  if(!add) do.call(plot,args)
  else do.call(lines,args)
  if(show.tree) plotTree(x$tree,add=TRUE,ftype="off",lwd=1,
                         color=make.transparent("blue",0.1),mar=par()$mar,
                         direction="leftwards",xlim=args$xlim)
}


plot.ctt(object, type="rate")

length(object$nchanges)
length(object$edge.length)



plot.multiCtt<-function(x,...){
  if(hasArg(alpha)) alpha<-list(...)$alpha
  else alpha<-0.05
  segments<-x[[1]]$segments
  nchanges<-sapply(x,function(x) x$nchanges)
  if(hasArg(type)) type<-list(...)$type
  else type<-"rate"
  edge.length<-sapply(x,function(x) x$edge.length)
  obj<-list(segments=segments,nchanges=rowMeans(nchanges),
            edge.length=rowMeans(edge.length),tree=x[[1]]$tree)
  class(obj)<-"ctt"
  lower<-max(floor(alpha/2*length(x)),1)
  upper<-min(ceiling((1-alpha/2)*length(x)),ncol(nchanges))
  xx<-max(nodeHeights(x[[1]]$tree))-as.vector(t(segments))
  xx<-c(xx,xx[length(xx):1])
  y.lower<-if(type=="number") apply(nchanges,1,sort)[lower,] else
    if(type=="rate") apply(nchanges/edge.length,1,sort)[lower,]
  y.upper<-if(type=="number") apply(nchanges,1,sort)[upper,] else
    if(type=="rate") apply(nchanges/edge.length,1,sort)[upper,]
  y.lower<-as.vector(rbind(y.lower,y.lower))
  y.upper<-as.vector(rbind(y.upper,y.upper))
  yy<-c(y.lower,y.upper[length(y.upper):1])
  args<-list(...)
  if(!is.null(args$alpha)) args$alpha<-NULL
  if(is.null(args$col)) args$col<-"blue"
  if(is.null(args$ylim)) args$ylim<-range(yy)
  args$x<-obj
  do.call(plot,args)
  polygon(xx,yy,col=make.transparent("grey",0.4),border=0)
}

plot.multiCtt(object_list, type="rate")
```

```{r}
library(ggplot2)


plot.ctt(object, type="rate")

m2o <- rates_df %>%
      filter(transition == "megaherbivore->other")
    
o2m <- rates_df %>%
      filter(transition == "other->megaherbivore")
    
ggplot() + 
      # Armature -> No Armature:
      geom_point(data = m2o, aes(x = time, y = rate, colour = "megaherbivore->other"), pch = 15) +
      geom_line(data = m2o, aes(x = time, y = rate, colour = "megaherbivore->other")) +
      
      # No Armature -> Armature:
      geom_point(data = o2m, aes(x = time, y = rate, colour = "other->megaherbivore"), pch = 17) +
      geom_line(data = o2m, aes(x = time, y = rate, colour = "other->megaherbivore")) +
      
    geom_point(data = avg_trans_times %>% filter(transition == "megaherbivore->other"), 
               aes(x = avg_time, y = avg_Nchanges / avg_edge.length, colour = "megaherbivore->other"), 
               pch = 15) +
  
    geom_line(data = avg_trans_times %>% filter(transition == "megaherbivore->other"),
            aes(x = avg_time, y = avg_Nchanges / avg_edge.length, colour = "megaherbivore->other")) +
  
  
    geom_point(data = avg_trans_times %>% filter(transition == "other->megaherbivore"),
             aes(x = avg_time, y = avg_Nchanges / avg_edge.length, colour = "other->megaherbivore"), 
             pch = 17) +
  
    geom_line(data = avg_trans_times %>% filter(transition == "other->megaherbivore"),
            aes(x = avg_time, y = avg_Nchanges / avg_edge.length, colour = "other->megaherbivore")) +
  
  
    # Set plot aesthetics
    theme_light() + 
    xlim(220, 0) +
    ylim(0, 0.28) +
    labs(
      x = "Time since the origin of clade (mya)",
      y = "relative changes per edge.length")

```


# Plot the rate 2

```{r}
library(ggplot2)
library(viridis)
rates_df %>% ungroup() %>% group_by(N_sim, transition) %>% 
  ggplot(aes(x = segs_end , y = rate, group = as.factor(transition), col = as.factor(transition))) +
  geom_point()+
  geom_line()


## Plots from pollination study:

mega2other <- rates_df %>%
  dplyr::filter(transition == "megaherbivore->other") %>%
  dplyr::mutate(mega2other = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(mega2other)

other2mega <- rates_df %>%
  dplyr::filter(transition == "other->megaherbivore") %>%
  dplyr::mutate(other2mega = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(other2mega)

# calculate density curve
density_a2na <- density(mega2other$mega2other)
density_na2a <- density(other2mega$other2mega)

# plot the density
plot(density_a2na, lwd = 2, col = myColours[1], 
     xlim = c(58,0), xlab = "Time of transitions (mya)", bty = "l", ylim=c(0, 0.2),
     cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
lines(density_na2a, lwd = 2, col = myColours[2], xlim = c(58,0))
```

