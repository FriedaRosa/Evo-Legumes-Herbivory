---
title: "CTT_plot_New"
author: "Friederike Wölke"
format: html
editor: visual
---

# My adaptation of original CTT function

```{r}
## computing the mean number of character changes through time from a set of stochastic map trees
## written by Liam J. Revell 2017, 2020


# adapted by Friederike Wölke 

ctt_relative<-function(trees,segments=20,...){
  if(!(inherits(trees,"multiSimmap")))
    stop("trees should be an object of class \"multiSimmap\".")
  tree<-as.phylo(trees[[1]])
  changes<-sapply(trees,getChanges)
  h<-max(nodeHeights(tree))
  b<-segments
  segs<-cbind(seq(0,h-h/b,h/b),
              seq(1/b*h,h,h/b))
  
  
  # edge.length <- numberic(b)                                                  # ChatGPT
  
                                                                                # this is not part of ChatGPTs script (only the parallelized one)
  nchanges<-rep(0,b)
  for(i in 1:length(changes)){
    for(j in 1:length(changes[[i]])){
      ind<-which((changes[[i]][j]>segs[,1])+
                   (changes[[i]][j]<=segs[,2])==2)
      nchanges[ind]<-nchanges[ind]+1/length(changes)
    }
  }
  
  # this is part of both
  LTT<-ltt(tree,plot=FALSE)
  LTT<-cbind(LTT$ltt[2:(length(LTT$ltt)-1)],
             LTT$times[2:(length(LTT$ltt)-1)],
             LTT$times[3:length(LTT$ltt)])
  ii<-1
  
  
                                                                                # this is not part of ChatGPT
  edge.length<-rep(0,b)
  
                                                                                # both
  for(i in 1:nrow(segs)){
    done.seg<-FALSE
    while(LTT[ii,2]<=segs[i,2]&&done.seg==FALSE){
      edge.length[i]<-edge.length[i]+
        LTT[ii,1]*(min(segs[i,2],LTT[ii,3])-
                     max(segs[i,1],LTT[ii,2]))
      if(LTT[ii,3]>=segs[i,2]) done.seg<-TRUE
      if(LTT[ii,3]<=segs[i,2]) ii<-if(ii<nrow(LTT)) ii+1 else ii
    }
  }
  
  
  object<-list(segments=segs,nchanges=nchanges,edge.length=edge.length,tree=tree, 
               rate=nchanges/edge.length)
  class(object)<-"ctt"
  object
  
}	

plot.ctt<-function(x,...){
  h<-max(nodeHeights(x$tree))
  args<-list(...)
  if(!is.null(args$type)){ 
    type<-args$type
    args$type<-NULL
  } else type<-"rate"
  if(!is.null(args$show.tree)){
    show.tree<-args$show.tree
    args$show.tree<-NULL
  } else show.tree<-FALSE
  if(!is.null(args$add)){ 
    add<-args$add
    args$add<-NULL
  } else add<-FALSE
  if(is.null(args$ylim)) 
    args$ylim<-c(0,max(x$nchanges/x$edge.length))
  if(is.null(args$xlim))
    args$xlim<-c(max(x$segments),min(x$segments))
  if(is.null(args$lwd)) args$lwd<-2
  if(is.null(args$xlab)) args$xlab<-"time since the present"
  if(is.null(args$ylab)) 
    args$ylab<- "mean number of changes / total edge length"
  args$type<-"l"
  args$x<-h-as.vector(t(x$segments))
  args$y<-rbind(x$nchanges/x$edge.length,x$nchanges/x$edge.length)
  if(!add) do.call(plot,args)
  else do.call(lines,args)
  if(show.tree) plotTree(x$tree,add=TRUE,ftype="off",lwd=1,
                         color=make.transparent("blue",0.1),mar=par()$mar,
                         direction="leftwards",xlim=args$xlim)
}

sim.ctt<-function(tree,Q,anc=NULL,nmaps=100,...){
  x<-as.factor(sim.history(tree,Q,anc=anc,message=FALSE)$states)
  while(length(levels(x))!=ncol(Q)) 
    x<-as.factor(sim.history(tree,Q,anc=anc,message=FALSE)$states)
  flush.console()
  cat("Starting stochastic mapping with simulated data vector.... ")
  flush.console()
  trees<-make.simmap(tree,x,Q=Q,nsim=nmaps,message=FALSE)
  cat("Done.\n")
  flush.console()
  ctt(trees,...)
}

sim.multiCtt<-function(tree,Q,anc=NULL,nmaps=100,nsim=100,...){
  object<-lapply(1:nsim,sim.ctt,tree=tree,Q=Q,anc=anc,nmaps=nmaps,...)
  ##	object<-replicate(nsim,sim.ctt(tree,Q,anc=anc,nmaps=nmaps,...),simplify=FALSE)
  class(object)<-"multiCtt"
  object
}

getChanges<-function(tree){
  states<-sort(unique(getStates(tree)))
  nc<-sapply(tree$maps,length)-1
  b<-which(nc>0)
  nc<-nc[b]
  xx<-vector()
  H<-nodeHeights(tree)
  for(i in 1:length(b)){
    for(j in 1:nc[i]){
      ss<-names(tree$maps[[b[i]]])[j+1]
      x<-rep(H[b[i],1]+cumsum(tree$maps[[b[i]]])[j],2)
      xx<-c(xx,setNames(x[1],
                        paste(names(tree$maps[[b[i]]])[j:(j+1)],
                              collapse="->")))
    }
  }
  xx
}

print.ctt<-function(x,...){
  cat("Object of class \"ctt\" consisting of:\n")
  cat("   (1) a matrix (segments) with the beginning & ending time of each segment.\n")
  cat("   (2) a vector (nchanges) with the mean number of changes in each segment.\n")
  cat("   (3) a vector (edge.length) containing the total edge length of each segement.\n")
  cat("   (4) an object of class \"phylo\".\n\n")
}

print.multiCtt<-function(x,...){
  cat(paste(length(x),"objects of class \"ctt\" in a list.\n\n"))
}

plot.multiCtt<-function(x,...){
  if(hasArg(alpha)) alpha<-list(...)$alpha
  else alpha<-0.05
  segments<-x[[1]]$segments
  nchanges<-sapply(x,function(x) x$nchanges)
  if(hasArg(type)) type<-list(...)$type
  else type<-"rate"
  edge.length<-sapply(x,function(x) x$edge.length)
  obj<-list(segments=segments,nchanges=rowMeans(nchanges),
            edge.length=rowMeans(edge.length),tree=x[[1]]$tree)
  class(obj)<-"ctt"
  lower<-max(floor(alpha/2*length(x)),1)
  upper<-min(ceiling((1-alpha/2)*length(x)),ncol(nchanges))
  xx<-max(nodeHeights(x[[1]]$tree))-as.vector(t(segments))
  xx<-c(xx,xx[length(xx):1])
  y.lower<-if(type=="number") apply(nchanges,1,sort)[lower,] else
    if(type=="rate") apply(nchanges/edge.length,1,sort)[lower,]
  y.upper<-if(type=="number") apply(nchanges,1,sort)[upper,] else
    if(type=="rate") apply(nchanges/edge.length,1,sort)[upper,]
  y.lower<-as.vector(rbind(y.lower,y.lower))
  y.upper<-as.vector(rbind(y.upper,y.upper))
  yy<-c(y.lower,y.upper[length(y.upper):1])
  args<-list(...)
  if(!is.null(args$alpha)) args$alpha<-NULL
  if(is.null(args$col)) args$col<-"blue"
  if(is.null(args$ylim)) args$ylim<-range(yy)
  args$x<-obj
  do.call(plot,args)
  polygon(xx,yy,col=make.transparent("grey",0.4),border=0)
}

```

# From Pollination study

```{r}
###### Script from Pollination study: https://github.com/rubysaltbush/pollination-macroevolution/


# this function comes from https://github.com/rubysaltbush/pollination-macroevolution/blob/main/scripts/functions/transition_times.R

transition_times <- function(simmap){
  # below adapted from Liam Revells' phytools blog 
  # http://blog.phytools.org/2015/08/getting-timing-of-trait-changes-from.html
  # extracts raw transition times from a simmap (collapses multiple transitions
  # down into single transition events)
  # get tips and their states
  x <- phytools::getStates(simmap,"tips")
  # get unique states
  states <- sort(unique(x))
  # get length of states
  m <- length(states)
  # below makes a little matrix describing transitions
  ct <- sapply(states, 
               function(x,y) sapply(y, function(y,x) paste(x,"->", y, sep=""), 
                                    x = x), y = states)
  rm(x, states)
  # then a matrix to invalidate self->self transitions
  ii <- matrix(TRUE, m, m)
  diag(ii) <- rep(FALSE, m)
  # then a list to store results in
  changes <- vector(mode="list", length = m*(m - 1))
  rm(m)
  # named by types of transitions
  names(changes) <- as.vector(ct[ii])
  rm(ct, ii)
  # then singling out maps where transitions happen (where there is more than 1 state)
  nc <- sapply(simmap$maps, length) - 1
  ind <- which(nc > 0)
  nc <- nc[ind]
  
  # getting the node heights (measure of time/branch lengths) across the tree
  H <- phytools::nodeHeights(simmap)
  maps <- simmap$maps[ind]
  # then looping through and calculating the node heights of each transition
  for(i in 1:length(maps)){
    for(j in 1:nc[i]){
      sc <- paste(names(maps[[i]])[j:(j + 1)], collapse = "->")
      h <- H[ind[i], 1] + cumsum(maps[[i]])[j]
      changes[[sc]] <- c(changes[[sc]], as.numeric(h))
    }
  }
  rm(nc, ind, h, H, i, j, sc, maps)
  # removing any nulls from list of changes and sorting small to large
  changes <- changes[!sapply(changes, is.null)]
  changes <- lapply(changes, sort, decreasing = FALSE)
  
  # now convert this changes list into nice data frame output
  output <- data.frame()
  for(i in 1:length(changes)){
    df <- dplyr::bind_cols(changes[i])
    df <- df %>%
      mutate(transition = colnames(df)) %>%
      rename(nodeheight = 1)
    output <- rbind(output, df)
  }
  
  # node heights are the height above the root, so time but inverse along the tree
  # to get time from node heights need to subtract from max height of tree
  output$time <- max(nodeHeights(simmap)) - output$nodeheight
  
  # get rid of nodeheight column
  output <- output[-1]
  
  # and return the output! to graph etc.
  output
}

## below adapted from other script:  https://github.com/rubysaltbush/pollination-macroevolution/blob/main/scripts/analysis/simmap.R

# apply function across list of multiple simulations
armature_transitions <- data.frame()
for(i in 1:length(mtrees)){
  temp <- cbind(i, transition_times(mtrees[[i]]))
  armature_transitions <- rbind(armature_transitions, temp)
}
rm(temp, i)

table(armature_transitions$transition)

# build new data frame with cumulative number of transitions
armature_trans_cumul <- data.frame()
for(n in 1:100){
  trans <- armature_transitions %>%
    dplyr::filter(i == n) %>%
    dplyr::group_by(transition) %>%
    dplyr::mutate(trans_no = row_number(i))
  
  armature_trans_cumul <- rbind(armature_trans_cumul, trans)
}
rm(n, trans)


##### copied from somewhere else in the code from the same script....:

# first need to know average number of transitions, rounded
trans_avg_length <- armature_trans_cumul %>%
  dplyr::group_by(transition, i) %>%
  dplyr::mutate(no_trans = max(trans_no)) %>%
  dplyr::ungroup() %>%
  dplyr::filter(trans_no == no_trans) %>%
  dplyr::group_by(transition) %>%
  dplyr::mutate(avg_length = round(mean(no_trans), digits = 0)) %>%
  dplyr::select(transition, avg_length) %>%
  dplyr::ungroup() %>%
  dplyr::distinct()

# now knowing this, can rearrange data and average times across rows
avg_trans_times <- armature_trans_cumul %>%
  dplyr::group_by(transition, trans_no) %>%
  dplyr::mutate(avg_time = mean(time)) %>%
  dplyr::mutate(SE_time = sqrt(var(time) / length(time))) %>%
  dplyr::select(transition, trans_no, avg_time, SE_time) %>%
  dplyr::distinct()

# reduce avg_trans_times to trans_avg_length
avg_trans_times_a2na <- avg_trans_times %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
avg_trans_times_na2a <- avg_trans_times %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])
avg_trans_times <- rbind(avg_trans_times_a2na, avg_trans_times_na2a)
rm(avg_trans_times_a2na, avg_trans_times_na2a)

# export these results to csv in case I need them
readr::write_csv(avg_trans_times, "../Fig4Pollination/mean_transition_times_armature_MCC.csv")



#### Plotting ======================================

# install.packages("prettyGraphs") #to set transparancy of colors with "alpha"
library(prettyGraphs)

myColours = c("steelblue", "#FFBB00")
myColoursAlpha <- add.alpha(myColours, alpha=0.4)
my_cols <- setNames(myColoursAlpha, c("armature->no_armature", "no_armature->armature"))

pdf("../Fig4Pollination/armature_transition_times_mean_hist.pdf", height = 2.8, width = 6)
min <- min(avg_trans_times$avg_time)
max <- max(avg_trans_times$avg_time)
ax <- pretty(min:35, n = 20)

arm_to_no_arm <- avg_trans_times %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::mutate(arm_to_no_arm = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(arm_to_no_arm)

no_arm_to_arm <- avg_trans_times %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::mutate(no_arm_to_arm = avg_time) %>%
  dplyr::ungroup() %>%
  dplyr::select(no_arm_to_arm)

a2na <- hist(arm_to_no_arm$arm_to_no_arm, breaks = ax, plot = FALSE)
na2a <- hist(no_arm_to_arm$no_arm_to_arm, breaks = ax, plot = FALSE)

plot (a2na, col = myColours[1], xlab = "Time of transitions (mya)",  
      main = "", ylab = "number of transitions", 
      ylim = c(0, 40), xlim = c(100,0)) # alter if x values change!
plot (na2a, col = my_cols[2], add = TRUE)


# data for density graph
arm_to_no_arm <- armature_transitions %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::mutate(arm_to_no_arm = time) %>%
  dplyr::select(arm_to_no_arm, simulation = i)
no_arm_to_arm <- armature_transitions %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::mutate(no_arm_to_arm = time) %>%
  dplyr::select(no_arm_to_arm, simulation = i)

# calculate density curve
density_a2na <- density(arm_to_no_arm$arm_to_no_arm)
density_na2a <- density(no_arm_to_arm$no_arm_to_arm)

# plot the density
plot(density_a2na, lwd = 2, col = myColours[1], 
     xlim = c(58,0), xlab = "Time of transitions (mya)", bty = "l", ylim=c(0, 0.2),
     cex.lab = 1.4, cex.axis = 1.4, main = NULL, sub = NULL, title = NULL)
lines(density_na2a, lwd = 2, col = myColours[2], xlim = c(58,0))

# add data-points with noise in the X-axis
rug(jitter(no_arm_to_arm$no_arm_to_arm), col = my_cols[1])
rug(jitter(arm_to_no_arm$arm_to_no_arm), col = my_cols[2])

dev.off()
##################

pdf("Fig4Pollination/RatesPlot.pdf", height = 8, width = 10)
par(mar = c(5.1, 5.1, 4.1, 2.1))    # increase margins

arm_to_no_arm <- armature_trans_cumul %>%
  dplyr::filter(transition == "armature->no_armature")

# first set up basic plot parameters
plot(arm_to_no_arm$trans_no ~ arm_to_no_arm$time,
     type = "p", bty = "l", xlim = c(100,0), ylim = c(0,60),
     col = my_cols[1], pch = 15,
     xlab = "Time of transitions (mya)", 
     ylab = "Cumulative number of transitions",
     cex.lab = 1.8, cex.axis = 1.8)

# then loop through all data and add all points and lines to plot for 1000 simulations
for(n in 1:1000){
  test <- armature_transitions %>%
    dplyr::filter(i == n) %>%
    dplyr::group_by(transition) %>%
    dplyr::mutate(trans_no = row_number(i))
  
  no_arm_to_arm <- test %>%
    dplyr::filter(transition == "no_armature->armature")
  arm_to_no_arm <- test %>%
    dplyr::filter(transition == "armature->no_armature")
  
  points(arm_to_no_arm$trans_no ~ arm_to_no_arm$time, 
         col = my_cols[1], pch = 15)
  lines(arm_to_no_arm$trans_no ~ arm_to_no_arm$time, 
        col = my_cols[1])
  points(no_arm_to_arm$trans_no ~ no_arm_to_arm$time, 
         col = my_cols[2], pch = 17)
  lines(no_arm_to_arm$trans_no ~ no_arm_to_arm$time, 
        col =my_cols[2])
}

# then add average points and line in blue
# first prep data
no_arm_to_arm <- avg_trans_times %>%
  dplyr::filter(transition == "no_armature->armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[1,2])
arm_to_no_arm <- avg_trans_times %>%
  dplyr::filter(transition == "armature->no_armature") %>%
  dplyr::filter(trans_no <= trans_avg_length[2,2])

# then add to plot
points(arm_to_no_arm$trans_no ~ arm_to_no_arm$avg_time,
       col = "blue", pch = 15)
lines(arm_to_no_arm$trans_no ~ arm_to_no_arm$avg_time, 
      col = "blue")
points(no_arm_to_arm$trans_no ~ no_arm_to_arm$avg_time,
       col = "darkblue", pch = 17)
lines(no_arm_to_arm$trans_no ~ no_arm_to_arm$avg_time, 
      col = "darkblue")

# add legend
legend("topleft",
       legend = c("armature->no_armature", "no_armature->armature"),
       col = c(my_cols[1],my_cols[2]),
       pch = c(15, 17), pt.lwd = 0.001, bty = "n", cex = 1.8)
dev.off()

```

# My Data

```{r}
# Read in the data and tree ============================
rm(list=ls())

library(phytools) # for phylo stuff
library(dplyr) # for data handling
library(evobiR) # To reorder data based on tree
library(geiger) # for Mk Models
library(tictoc) # for time measurements of computations

traitData <- read.csv("../input/Matrix_all_traits.csv", stringsAsFactors = FALSE, header = TRUE)
tree <- read.tree("../input/Mimo_metachronogram_mmc.tre")
tree <- as.phylo(tree)
new_tip_names<-read.csv("../input/replace_tip_labels.csv")

# Subset data by trait 
armature <- traitData %>% select(Taxon, Armatures) %>% filter(!is.na(Taxon) & !is.na(Armatures)) %>% distinct(.) # 2 species were duplicated (Acacia baileyana and Chidlowiana sanguinea)

# Correct tip names in the tree with new labels
tree2 <- tree
tree2$tip.label <- new_tip_names[[2]][match(tree$tip.label, new_tip_names[[1]])]


# Small subset with 10 species:

#armature <- armature[1:10,]


# match data and tree ===================================
row.names(armature) <- armature$Taxon
sp_drop <- setdiff(tree2$tip.label, armature$Taxon)

# Drop these species from the tree, because we need matching data between tree and traits
tree3 <- drop.tip(tree2, sp_drop)
tree4 <- ladderize(tree3)

matches <- match(armature$Taxon, tree4$tip.label, nomatch = 0)
armature2 <- subset(armature, matches != 0)

setdiff(tree4$tip.label, armature2$Taxon) # 0
setdiff(armature2$Taxon, tree4$tip.label) # 0

tree <- tree4

# Make data for Mk models for Armature

armature2[armature2=="0"] <- "no_armature"
armature2[armature2=="1"] <- "armature"

trait <- unique(armature2)
trait <- ReorderData(tree, trait, taxa.names = "row names")

trait$Armatures <- as.factor(trait$Armatures)
trait$Taxon <- NULL

# Clean environment to free memory:
rm(tree2, tree3, tree4, traitData, new_tip_names, armature, matches, sp_drop)

# Mk models ============================
# estimate the rates of transitioning between ancestral states given a hypothesis (either equal rates(ER), or different rates(ARD))

# computing time = 11.58s
tic()
  equal <- fitDiscrete(tree, trait, model = "ER")
toc()

# computing time = 42.85s
tic()
  ard <- fitDiscrete(tree, trait, model = "ARD")
toc()

# Calculate AIC weights
aic.discrete <- setNames(c(equal$opt$aic, ard$opt$aic), c("equal", "different"))
weights <- aicw(aic.discrete)
weights # ARD model performs better for armature/no armature

# we need a slightly different format for Simmap:
trait2 <- as.factor(trait$Armatures)
names(trait2) <- rownames(trait)

# For 100 simulation (nsim=100) --> computing time = 725.28s && 373.7 sec elapsed
tic()
  mtrees <- make.simmap(tree, trait2, model = "ARD", nsim = 100)
toc()

saveRDS(mtrees, "../output/RDS/mtrees_multiSimmap.rds")

# 6.35s
tic()
  pd_mtrees <- describe.simmap(mtrees, plot = FALSE)
toc()
```

My adaptation

```{r}

transition_times <- function(simmap){
  # below adapted from Liam Revells' phytools blog 
  # http://blog.phytools.org/2015/08/getting-timing-of-trait-changes-from.html
  # extracts raw transition times from a simmap (collapses multiple transitions
  # down into single transition events)
  # get tips and their states
  
  
  
  x <- phytools::getStates(simmap,"tips")
  levs<-sort(unique(c(getStates(tree,"tips"),
                      getStates(tree,"nodes"))))

  
  # get unique states

  # get length of states
  m <- length(levs)
  # below makes a little matrix describing transitions
  ct <- sapply(levs, 
               function(x,y) sapply(y, function(y,x) paste(x,"->", y, sep=""), 
                                    x = x), y = levs)


  
  
  
  
  # 
  H <- phytools::nodeHeights(ct)
  h<-c(0,max(H)-branching.times(ct),min(sapply(1:Ntip(ct),
                                               nodeheight,tree=ct)))
  ss<-setNames(as.factor(names(ct$edge.length)),
               ct$edge[,2])
  lineages<-matrix(0,length(h),length(levs),
                   dimnames=list(names(h),levs))
  lineages[1,getStates(tree,"nodes")[1]]<-1
  for(i in 2:length(h)){
    ii<-intersect(which(h[i]>H[,1]),which(h[i]<=H[,2]))
    lineages[i,]<-summary(ss[ii])
  }
  

  ii<-order(h)
  times<-h[ii]
  

  lineages<-lineages[ii,]
  lineages<-cbind(lineages,total=rowSums(lineages))
  obj<-list(ltt=lineages,times=times,tree=tree)
  }

```

# My adaptation (in loop, save to list)

```{r}
tic()
rm(list=ls())
mtrees <- readRDS("../output/RDS/mtrees_multiSimmap.rds")

### Required function ========================================================================== #
getChanges<-function(tree){
  states<-sort(unique(getStates(tree)))
  nc<-sapply(tree$maps,length)-1
  b<-which(nc>0)
  nc<-nc[b]
  xx<-vector()
  H<-nodeHeights(tree)
  for(i in 1:length(b)){
    for(j in 1:nc[i]){
      ss<-names(tree$maps[[b[i]]])[j+1]
      x<-rep(H[b[i],1]+cumsum(tree$maps[[b[i]]])[j],2)
      xx<-c(xx,setNames(x[1],
                        paste(names(tree$maps[[b[i]]])[j:(j+1)],
                              collapse="->")))
    }
  }
  xx
}

plot.ctt<-function(x,...){
  h<-max(nodeHeights(x$tree))
  args<-list(...)
  if(!is.null(args$type)){ 
    type<-args$type
    args$type<-NULL
  } else type<-"rate"
  if(!is.null(args$show.tree)){
    show.tree<-args$show.tree
    args$show.tree<-NULL
  } else show.tree<-FALSE
  if(!is.null(args$add)){ 
    add<-args$add
    args$add<-NULL
  } else add<-FALSE
  if(is.null(args$ylim)) 
    args$ylim<-c(0,max(x$nchanges/x$edge.length))
  if(is.null(args$xlim))
    args$xlim<-c(max(x$segments),min(x$segments))
  if(is.null(args$lwd)) args$lwd<-2
  if(is.null(args$xlab)) args$xlab<-"time since the present"
  if(is.null(args$ylab)) 
    args$ylab<- "mean number of changes / total edge length"
  args$type<-"l"
  args$x<-h-as.vector(t(x$segments))
  args$y<-rbind(x$nchanges/x$edge.length,x$nchanges/x$edge.length)
  if(!add) do.call(plot,args)
  else do.call(lines,args)
  if(show.tree) plotTree(x$tree,add=TRUE,ftype="off",lwd=1,
                         color=make.transparent("blue",0.1),mar=par()$mar,
                         direction="leftwards",xlim=args$xlim)
}



# ============================================================================================= #
# Create a function to find the segment ID for a given time value:
# ============================================================================================= #
find_segment_id <- function(time) {
  segment_indices <- cut(time, breaks = segs_df[, 2], labels = FALSE)
  return(segs_df$segsID[segment_indices])
  }
## ============================================================================================= #


# ====================================================================================================== #
## Step 2: Loop over each simulation and extract 
# - breaks for segments
# - edge.lengths
# - rates for each character state transition
# ====================================================================================================== #


object_list <- list()
rates_list <- list()

# First Level of the loop  
for (Nsimulation in 1:100){ 
  
  b<-20    # set the number of time-segments for which everything will be calculated.
   
  tree <- as.phylo(mtrees[[Nsimulation]])
 
  h<-max(nodeHeights(tree))
  segs<-cbind(seq(0,h-h/b,h/b),
              seq(1/b*h,h,h/b))

  
  
  changes<-sapply(mtrees, getChanges) 

  nchanges<-rep(0,b)
  for(i in 1:length(changes)){
  
    for(j in 1:length(changes[[i]])){
    
      ind<-which((changes[[i]][j]>segs[,1])+ 
                   (changes[[i]][j]<=segs[,2])==2)
      nchanges[ind]<-nchanges[ind]+1/length(changes)
      
      } # closing of 2nd level
    
    } # closing of 1st level

  rm(i,j)  
  

  changes_table <- data.frame(transitions = rownames(t(do.call(rbind,changes))),
                             t(do.call(rbind,changes)), 
                             row.names = NULL)

  ## Edge.Lengths =========================================================================== #
  
  ## For one tree
  tic("ltt function")
  LTT<-ltt(tree,plot=FALSE)
	toc() #24.5 seconds
	
  LTT<-cbind(LTT$ltt[2:(length(LTT$ltt)-1)],
	LTT$times[2:(length(LTT$ltt)-1)],
  LTT$times[3:length(LTT$ltt)])
  
	ii<-1

	# Create an empty vector to store edge lengths
	edge.length <- rep(0, nrow(segs))

	
	# 2nd level loop: 
	# (for one tree because LTT is calculated for one tree)
   for (i_segs in 1:nrow(segs)) {
     

     # Find the indices of LTT segments that overlap with the current segs segment
     overlap_indices <- which(LTT[, 2] <= segs[i_segs, 2] & LTT[, 3] >= segs[i_segs, 1])
  

     # Calculate edge length for the current segs segment using vectorized operations
     # 3rd level loop: 
     for (ii in overlap_indices) {
     
       # edge.length should contain the edge lengths for all segments:  
       edge.length[i_segs] <- edge.length[i_segs] +        
         LTT[ii, 1] * 
         (min(segs[i_segs, 2], LTT[ii, 3]) - 
            max(segs[i_segs, 1], LTT[ii, 2])) 

     
       } # 3rd level closing
     
   } # 2nd level closing
     
	
	edge.length_backup <- edge.length
	edge.length <-c(1, edge.length)

  # edge.length should contain the edge lengths for all segments in a given simulation
 	# adding segsID coulmn to edge lengths
	 	edge.length_df <- data.frame(edge.length = edge.length, segsID = seq(1,b+1))
     
     	  
# ============================================================================================= #
# Create a dataframe with transitions, times, edge.lengths, segment IDs.
# ============================================================================================= #
	  ## first level loop: along simulations
	  
	 	# Again extract changes for each simulation separately:
	  current_simulation <- as.data.frame(changes[[Nsimulation]], 
	                                      row.names = names(changes[[Nsimulation]]))
	  names(current_simulation) <- c("time")
	  current_simulation$transition <- rownames(current_simulation)
	 	current_simulation$N_sim <- Nsimulation
	 	current_simulation$IDtransition <- seq(1:nrow(current_simulation))

	 	
	 	# ============================================================================================= #
	 	# Working the segments: 
	 	# ============================================================================================= #

	 	
	 	# Create a vector of segment IDs
	 	segs_df <- as.data.frame(segs)
	 	new_row <- data.frame(V1 = 0, V2 = 0)
	 	segs_df <- rbind(new_row, segs_df)
	 	segs_df$segsID <- seq(1,b+1) # now we can calculate the breaks from it


	 	
	 	# Use the apply function to find the segment ID for each row in current_simulation

	 	current_simulation$segsID <- apply(current_simulation, 1, function(row) {
  
	 	  time <- as.numeric(row["time"])
	 	  return(find_segment_id(time))

	 	  }) # closing loop from within the apply-function (3rd level loop closing)

	 
	 	
	 	# assign here edge.length based on segment ID
	 	current_simulation <- unique(merge(current_simulation, edge.length_df, by="segsID", all = T))
	 	names(segs_df) <- c("segs_start", "segs_end", "segsID")
	  current_simulation <-	unique(merge(current_simulation, segs_df, by = "segsID", all = T))
	 	# Calculate rate for each simulation:
	 	
	 	current_simulation_rates <- current_simulation %>% 
	 	  group_by(segsID, N_sim, transition) %>% 
	 	  mutate(Nchanges = sum(!is.na(IDtransition))) %>% 
	 	  mutate(rate = Nchanges / edge.length)

	 	
	 	
	  rates_list[[Nsimulation]] <- current_simulation_rates
	  
	  object <-list(segments=segs, nchanges=nchanges, edge.length=edge.length, tree=tree, rate = nchanges/edge.length)
	class(object)<-"ctt"
	object
	
	
	object_list[[Nsimulation]] <- object 
	  
} # 1st level closing
toc()  # 1218.6 sec elapsed = 20.3 min
plot.ctt(object, type = "rate")
rates_df <- do.call(rbind, rates_list)

# save.image("~/GitHub/Evo-Legumes-Herbivory/LegumesArmature/output/RData/rates_ws.RData")


```

```{r}
library(ggplot2)
library(viridis)
rates_df %>% ungroup() %>% group_by(N_sim, transition) %>% 
  ggplot(aes(x = segs_end , y = rate, group = as.factor(transition), col = as.factor(transition))) +
  geom_point()+
  geom_line()+
  scale_color_viridis(discrete=T, alpha = 0.6)
```

\
\
