"0","tic( ""loop"")"
"0","rm(list=ls())"
"0","mtrees <- readRDS(""../output/RDS/mtrees_multiSimmap.rds"")"
"0",""
"0","### Required function ========================================================================== #"
"0","getChanges<-function(tree){"
"0","  states<-sort(unique(getStates(tree)))"
"0","  nc<-sapply(tree$maps,length)-1"
"0","  b<-which(nc>0)"
"0","  nc<-nc[b]"
"0","  xx<-vector()"
"0","  H<-nodeHeights(tree)"
"0","  for(i in 1:length(b)){"
"0","    for(j in 1:nc[i]){"
"0","      ss<-names(tree$maps[[b[i]]])[j+1]"
"0","      x<-rep(H[b[i],1]+cumsum(tree$maps[[b[i]]])[j],2)"
"0","      xx<-c(xx,setNames(x[1],"
"0","                        paste(names(tree$maps[[b[i]]])[j:(j+1)],"
"0","                              collapse=""->"")))"
"0","    }"
"0","  }"
"0","  xx"
"0","}"
"0",""
"0",""
"0",""
"0","# ============================================================================================= #"
"0","# Create a function to find the segment ID for a given time value:"
"0","# ============================================================================================= #"
"0",""
"0","find_segment_id <- function(time) {"
"0","  segment_indices <- cut(time, breaks = segs_df[, 2], labels = FALSE)"
"0","  return(segs_df$segsID[segment_indices])"
"0","}"
"0",""
"0","## ============================================================================================= #"
"0",""
"0",""
"0","  # ================================================================= #"
"0","  # Working the multiSiammp"
"0","  # ================================================================= #"
"0",""
"0","  "
"0","  "
"0","  # Get all changes from all simulations so that we can loop through them:"
"0","  changes <- sapply(mtrees, getChanges) "
"0","  "
"0","  "
"0","  # Transform the original changes list of matrices from sapply() for all simulations to dataframe "
"0","  # add trans_no to each transition based on grouping by transition "
"0","  # (i.e, there are two trans_no = 1, one for each transition type)"
"0","  "
"0","  i_changes_list <- list() "
"0","  for (i in 1:length(changes)) {"
"0","    "
"0","    i_changes <- changes[[i]] # for each simulation from multiSimmap"
"0","    "
"0","    "
"0","    # extract transition types and times and assign ID column for simmap simulation"
"0","    i_changes_df <- data.frame(transition = names(i_changes), time = i_changes, N_sim = i)"
"0","    i_changes_df$transition <- as.factor(i_changes_df$transition)"
"0","    "
"0","    # Add trans_no to each transition from a group (transition type)"
"0","    i_changes_df <- i_changes_df %>%  arrange(time) %>%"
"0","      group_by(transition) %>%"
"0","      mutate(trans_no = row_number())"
"0","    "
"0","    i_changes_list[[i]] <- i_changes_df"
"0","    "
"0","  }"
"0","  "
"0","  # Final Table without edge.lengths:"
"0","  changes_table <- plyr::rbind.fill(i_changes_list, fill=T)"
"0","  changes_table_wo_edge <- changes_table"
"0",""
"0",""
"0","  "
"0","# ====================================================================================================== #"
"0","## Step 1: Loop over each simulation and extract "
"0","# - breaks for segments"
"0","# - edge.lengths"
"0","# - rates for each character state transition"
"0","# ====================================================================================================== #"
"0",""
"0",""
"0","object_list <- list()"
"0","rates_list <- list()"
"0",""
"0",""
"0",""
"0","# First Level of the loop  "
"0","for (Nsimulation in 1:100){ "
"0","  "
"0","  "
"0","  # ====================================================================================================== #"
"0","  # Setting global variables for the Analysis"
"0","  # ====================================================================================================== #"
"0","  "
"0","  # set the number of time-segments for which everything will be calculated:"
"0","  b <- 20    "
"0","  "
"0","  # reduce to one tree to extract parameters from each simulation separately:"
"0","  tree <- as.phylo(mtrees[[Nsimulation]])"
"0","  "
"0","  # extract time since root"
"0","  h <- max(nodeHeights(tree))"
"0","  "
"0","  # calculate the time segments based on time since the origin and the time segments that were set by the user"
"0","  segs <- cbind(seq(0,h-h/b,h/b),"
"0","              seq(1/b*h,h,h/b))"
"0",""
"0","  "
"0","  # ====================================================================================================== #"
"0","  # Transitions & Timing  (getChanges)"
"0","  # ====================================================================================================== #"
"0","  "
"0","  "
"0","  # ================================================================= #"
"0","  # Working changes from each simmap simulation separately:"
"0","  # ----------------------------------------------------------------- #"
"0","  # Changes per Segments:"
"0","  # ================================================================= #"
"0","  "
"0",""
"0","# Loop through all changes & Calculate average number of changes per time interval (segs; set with ""b"")"
"0","  "
"0","  nchanges<-rep(0,b)"
"0","  for(i in 1:length(changes)) { # loop through all simulations from simmap  "
"0",""
"0","# loop through all individual changes from one simmap simulation and calculate relative changes per time segment"
"0","# nchanges = collects the relative number of changes (of all changes) per segment"
"0","    "
"0","    for(j in 1:length(changes[[i]])) { "
"0","      "
"0","      ind<-which((changes[[i]][j]>segs[,1])+ "
"0","                   (changes[[i]][j]<=segs[,2])==2)"
"0","      nchanges[ind]<-nchanges[ind]+1/length(changes)"
"0","      "
"0","      } # closing of 2nd level"
"0","    "
"0","    } # closing of 1st level"
"0",""
"0","  rm(i,j)  "
"0","  "
"0","  "
"0","  # ================================================================= #"
"0","  # Working changes from each simmap simulation separately:"
"0","  # ----------------------------------------------------------------- #"
"0","  # Edge Lengths per Segments:"
"0","  # ================================================================= #"
"0",""
"0","  # Edge.Lengths = Number of species in the phylogeny per time slot (increases naturally with time)"
"0","  # ! Note: has to be accounted for when showing transition rates"
"0","  # Here we calculate edge lengths for each segement separatly:"
"0","  "
"0","  # -------------------------------------------------------------------------------------------------------- #"
"0","  "
"0","  # Compute Lineages-Through-Time with ltt() function from the phytools package to extract edge.lengths from"
"0","  LTT <- ltt(tree,plot=FALSE)"
"0",""
"0","	# transform LTT data so that we can use it:"
"0","  LTT <- cbind(LTT$ltt[2:(length(LTT$ltt)-1)],                # Number of species at each node minus the root"
"0","               LTT$times[2:(length(LTT$ltt)-1)],              # ""start"" time for each node minus the root"
"0","               LTT$times[3:length(LTT$ltt)])                  # ""end"" time for each node minus the root"
"0","  "
"0","  # -------------------------------------------------------------------------------------------------------- #"
"0","  "
"0","  ## Now we loop through all segments to extract matching edge.lengths =================================== #"
"0","  "
"0","  # set count variable:"
"0","	ii<-1"
"0",""
"0","	# Create an empty vector to store edge lengths"
"0","	edge.length <- rep(0, nrow(segs))"
"0",""
"0","	"
"0","	# 2nd level loop: "
"0","	# (for one tree because LTT is calculated for one tree)"
"0","   for (i_segs in 1:nrow(segs)) {"
"0","     "
"0",""
"0","     # Find the indices of LTT segments that overlap with the current segs segment"
"0","     overlap_indices <- which(LTT[, 2] <= segs[i_segs, 2] & LTT[, 3] >= segs[i_segs, 1])"
"0","  "
"0",""
"0","     # Calculate edge length for the current segs segment using vectorized operations"
"0","     # 3rd level loop: "
"0","     for (ii in overlap_indices) {"
"0","     "
"0","       # edge.length should contain the edge lengths for all segments:  "
"0","       edge.length[i_segs] <- edge.length[i_segs] +        "
"0","         LTT[ii, 1] * # counts number of lineages between time intervals"
"0","         (min(segs[i_segs, 2], LTT[ii, 3]) - # end time interval"
"0","            max(segs[i_segs, 1], LTT[ii, 2]))  # start time interval"
"0",""
"0","     "
"0","       } # 3rd level closing"
"0","     "
"0","   } # 2nd level closing"
"0","	"
"0","	"
"0","	edge.length_backup <- edge.length"
"0","	edge.length <-c(1, edge.length)"
"0","  # edge.length should contain the edge lengths for all segments in a given simulation"
"0"," 	"
"0","	# adding segsID coulmn to edge lengths:"
"0","	edge.length_df <- data.frame(edge.length = edge.length, segsID = seq(1,b+1))"
"0","	"
"0","	"
"0","	#########################################################################################################"
"0","	# WIP: "
"0","	#########################################################################################################"
"0","	"
"0","	"
"0","	"
"0","	# ================================================================= #"
"0","  # Working the multiSimmap:"
"0","  # ----------------------------------------------------------------- #"
"0","  # Edge Lengths at each transition event"
"0","  # ================================================================= #"
"0","	## Adapted code from the segments by me"
"0","	"
"0","	# we need the table for all simmaps: changes_table so that we can loop through it"
"0","	"
"0","	# set count variable:"
"0","	ii<-1"
"0",""
"0","	# Create an empty vector to store edge lengths"
"0","	edge.length_transitions <- rep(0, nrow(changes_table))"
"0","  edge.lengths_all <- list()"
"0","	changes_times <- changes_table$time"
"0","	"
"0","	"
"0","	# 2nd level loop: "
"0","	# (for one tree because LTT is calculated for one tree)"
"0","   for (i_changes in 1:nrow(changes_table)) {"
"0",""
"0","     # Find the indices of LTT segments that overlap with the current segs segment"
"0","     "
"0","     # ""which start times of the Lineages are smaller or equal to the time the change happened and which end times of the lineages are larger or equal to the time the change happend."""
"0","     # --> this gives the node numbers that were there when the transition happend"
"0","     "
"0","     overlap_indices <- which(LTT[, 2] <= changes_times[i_changes] & LTT[, 3] >= changes_times[i_changes])"
"0","  "
"0",""
"0","     # Calculate edge length for the current segs segment using vectorized operations"
"0","     # 3rd level loop: "
"0","     "
"0","     for (ii in overlap_indices) { # ii = number of lineages when a transition occurred"
"0","     "
"0","       # edge.length should contain the edge lengths for all segments:  "
"0","       edge.length_transitions[i_changes] <- edge.length_transitions[i_changes] +        "
"0","         LTT[ii, 1] "
"0","       "
"0","       edge.length_transitions2 <- data.frame(time = changes_times[i_changes], edge.length = edge.length_transitions[i_changes])"
"0",""
"0","     "
"0","       edge.lengths_all[[i_changes]] <- edge.length_transitions2"
"0","       "
"0","       } # 3rd level closing"
"0","     "
"0","   } # 2nd level closing"
"0","	"
"0","  "
"0","  edge.lengths_all_df <- plyr::rbind.fill(edge.lengths_all)"
"0","  changes_table_w_edge <- merge(changes_table_wo_edge, edge.lengths_all_df, by = ""time"")"
"0","  # Write to file (once is enough)"
"0","  write.csv(changes_table_w_edge, ""../output/CSV/changes_table_w_edgelengths.csv"")"
"0","	"
"0","#########################################################################################################"
"0","# END WIP "
"0","#########################################################################################################"
"0","	"
"0","     	  "
"0","# ============================================================================================= #"
"0","# Create a dataframe with transitions, times, edge.lengths, segment IDs."
"0","# ============================================================================================= #"
"0","	  "
"0","  ## We are here = first level loop: along simulations"
"0","	  "
"0","	 	# Again extract changes for each simulation separately:"
"0","	  current_simulation <- as.data.frame(changes[[Nsimulation]], "
"0","	                                      row.names = names(changes[[Nsimulation]]))"
"0","	  names(current_simulation) <- c(""time"")"
"0","	  current_simulation$transition <- rownames(current_simulation)"
"0","	 	current_simulation$N_sim <- Nsimulation"
"0","	 	current_simulation <- current_simulation %>% arrange(time)"
"0","	 	current_simulation$IDtransition <- seq(1:nrow(current_simulation))"
"0",""
"0","	 	"
"0","	 	# ============================================================================================= #"
"0","	 	# Working the segments: "
"0","	 	# ============================================================================================= #"
"0",""
"0","	 	"
"0","	 	# Create a vector of segment IDs"
"0","	 	segs_df <- as.data.frame(segs)"
"0","	 	new_row <- data.frame(V1 = 0, V2 = 0)"
"0","	 	segs_df <- rbind(new_row, segs_df)"
"0","	 	segs_df$segsID <- seq(1,b+1) # now we can calculate the breaks from it"
"0",""
"0","	 	# Use the apply function to find the segment ID for each row in current_simulation"
"0","	 	current_simulation$segsID <- apply(current_simulation, 1, function(row) {"
"0","  "
"0","	 	  time <- as.numeric(row[""time""])"
"0","	 	  return(find_segment_id(time))"
"0",""
"0","	 	  }) # closing loop from within the apply-function (2nd level loop closing)"
"0",""
"0","	"
"0","	 	# assign edge.length based on segment ID"
"0","	 	current_simulation <- unique(merge(current_simulation, edge.length_df, by=""segsID"", all = T))"
"0","	 	names(segs_df) <- c(""segs_start"", ""segs_end"", ""segsID"")"
"0","	  current_simulation <-	unique(merge(current_simulation, segs_df, by = ""segsID"", all = T))"
"0","	 	"
"0","	  # Calculate rate for each simulation:"
"0","	 	current_simulation_rates <- current_simulation %>% "
"0","	 	  group_by(segsID, N_sim, transition) %>% "
"0","	 	  mutate(Nchanges = length(!is.na(IDtransition))) %>% "
"0","	 	  mutate(rate = Nchanges / edge.length)"
"0",""
"0","	 rates_list[[Nsimulation]] <- current_simulation_rates"
"0","	  "
"0","	 object <-list(segments=segs, "
"0","	               nchanges=nchanges, "
"0","	               edge.length=edge.length[-1], "
"0","	               tree=tree)"
"0","	 "
"0","	class(object)<-""ctt"""
"0","	object_list[[Nsimulation]] <- object "
"0","	  "
"0","} # 1st level closing"
"0",""
"0","toc()  # 1218.6 sec elapsed = 20.3 min"
"1","loop: 2707.4 sec elapsed
"
"0","class(object_list) <-""multiCtt"""
"0",""
"0","save.image(""~/GitHub/Evo-Legumes-Herbivory/LegumesArmature/output/RData/rates_ws.RData"")"
